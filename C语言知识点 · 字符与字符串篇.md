# C语言知识点 · 字符与字符串篇

## 答疑：

### 1、请你详细说说，printf与putchar与puts有什么异同？

| 特性维度     | `printf`                                   | `putchar`                              | `puts`                             |
| :----------- | :----------------------------------------- | :------------------------------------- | :--------------------------------- |
| **核心功能** | 格式化输出，功能强大                       | 输出**单个**字符                       | 输出**字符串**，并**自动换行**     |
| **输出参数** | 支持多种类型（整数、浮点、字符串等）       | 字符常量、变量或ASCII整数值            | 字符串常量、字符数组名或字符指针   |
| **换行行为** | **不自动换行**，需手动添加 `\n`            | **不自动换行**，需手动添加 `\n`        | **自动在末尾添加换行符** (`\n`)    |
| **返回值**   | 成功时返回输出的**字符总数**               | 成功返回**输出的字符**，失败返回 `EOF` | 成功返回**非负值**，失败返回 `EOF` |
| **性能特点** | 功能全面但开销相对较大（需解析格式字符串） | 最轻量高效，适合处理大量字符           | 简单高效，适合字符串输出           |



###2、%s与%c格式分别支持哪一些输出参数与输入参数？

| 特性维度         | **`%c`(字符格式符)**                                      | **`%s`(字符串格式符)**                                       |
| :--------------- | :-------------------------------------------------------- | :----------------------------------------------------------- |
| **对应数据类型** | `char`                                                    | `char*`(即字符指针) 或 `char[]`(字符数组)                    |
| **输出参数**     | `char`类型的变量、常量或整型值(ASCII码)                   | ==字符数组名、字符指针或字符串常量(代表字符串起始地址)==     |
| **输出行为**     | 输出**单个**字符                                          | 从给定地址开始，输出字符直到遇到**空字符`\0`**               |
| **输入参数**     | **必须**传入`char*`类型，即字符变量的地址(如 `&char_var`) | **必须**传入`char*`类型，通常是字符数组名或已分配内存的指针  |
| **输入行为**     | 读取并存储**下一个**字符(包括空格、换行符)                | 读取字符直到遇到**空白字符**(如空格、换行符)，并自动添加`\0` |



###3、给字符数组赋值时使用字符串初始化，**花括号 `{}`可以省略吗？**

​	在C语言中，给字符数组赋值时，使用字符串初始化，**花括号 `{}`是可以省略的**。所以，即使缺少了 `{}`，代码也是完全正确和常见的写法。

| 初始化场景               | 代码示例                              | 是否**可以**省略 `{}` | 说明与解释                                       |
| :----------------------- | :------------------------------------ | :-------------------- | :----------------------------------------------- |
| **使用字符串常量初始化** | `char str[] = "Hello";`               | **可以**              | 这是C语言标准允许的语法糖，编译器会自动处理。    |
| **使用字符列表初始化**   | `char str[] = {'H','e','l','l','o'};` | **不可以**            | 此时必须使用花括号来明确标识这是一个初始化列表。 |



### 4、请你详细说说，scanf与gets与fgets有什么异同？

​	在C语言中，`scanf`、`gets`和 `fgets`都用于输入，但它们在安全性、处理方式和适用场景上差异很大。为了让你快速掌握核心区别，我准备了一个对比表格，然后我们再深入聊聊细节和使用建议。

| 特性维度            | **`scanf`**                                            | **`gets`(已废弃)**                             | **`fgets`(推荐)**                                          |
| :------------------ | :----------------------------------------------------- | :--------------------------------------------- | :--------------------------------------------------------- |
| **主要功能**        | 格式化输入，读取**单词**                               | 读取整行输入，直到换行符                       | 读取整行输入，或达到指定字符数                             |
| **安全性**          | **较低**，使用`%s`易溢出，需指定宽度（如`%99s`）       | **极低**，**绝对不要使用**，无法防止缓冲区溢出 | **高**，可指定最大读取字符数，有效防止溢出                 |
| **空格/换行符处理** | 遇到**空格、制表符、换行符**即停止读取（当使用`%s`时） | 读取到换行符停止，**丢弃**换行符，自动添加`\0` | 读取到换行符或达到字符数限制停止，**保留**换行符在字符串中 |
| **结束标志**        | 空白字符或根据格式字符串                               | 换行符或EOF                                    | 换行符、EOF或达到指定最大字符数                            |
| **返回值**          | 成功读取并赋值的**数据项个数**                         | 成功返回传入的**指针**，错误或EOF返回`NULL`    | 成功返回传入的**指针**，错误或EOF返回`NULL`                |

#### 🔧 `scanf`：格式化的高手，但需谨慎 ####

​	`scanf`非常适合读取结构规整的数据，比如整数、浮点数或**不包含空格的单个单词**。它的强大在于其格式控制，但也因此更复杂。

- **安全使用`%s`**：直接用`%s`读取字符串非常危险，因为它不知道目标数组的大小。**必须指定字段宽度**来限制读取的最大字符数，这个宽度应比数组长度小1（为字符串结束符`\0`留空间）。

​	`char str[100]; scanf("%99s", str); // 安全：最多读取99个字符`

- **读取带空格的整行**：==如果想用`scanf`读取包含空格的整行文本，可以使用`%[^\n]`格式说明符，它表示读取所有字符直到遇到换行符。==同样需要指定宽度：`scanf("%99[^\n]", str); // 读取一行，直到遇到换行符`

#### ⚠️ `gets`：已被废弃的“陷阱” ####

​	**在任何情况下都不应再使用`gets`函数**。因为它完全不检查目标缓冲区的大小，如果用户输入的数据过长，就会导致**缓冲区溢出**，这可能破坏程序其他数据，甚至被恶意利用执行任意代码。C11标准已将其从语言标准中移除。

#### ✅ `fgets`：安全可靠的选择 ####

​	对于读取字符串，尤其是来自用户输入或文件的整行文本，`fgets`是**最推荐**的方法。

- **处理换行符**：`fgets`会将换行符一同读入字符串。通常我们需要手动移除它：`char str[100]; fgets(str, 100, stdin); // 去除换行符 size_t len = strlen(str); if (len > 0 && str[len-1] == '\n') {    str[len-1] = '\0'; }`



### 5、比较两个字符串是否相等的表达式为（a==b）吗？

在C语言中直接用 `a==b`比较字符串，实际上比较的是两个字符串的**内存地址**，而不是内容本身。正确做法是使用 **strcmp()函数**。

---

##代码实例：

####1、假设`scanf`语句执行时输入`ABCDE`<回车>，能使`puts(s)`语句正确输出`ABCDE`字符串的程序段是__。我感觉四个选项都有点问题？A选项与B选项没有在字符串的末尾添加'\0'，C选项与D选项的s都是野指针。

```c
char s[5]={"ABCDE"}; puts(s);
```

```c
char s[5]={'A', 'B', 'C', 'D', 'E'}; puts(s);
```

```c
char *s; scanf("%s", s); puts(s);    
```

```c
char *s; s="ABCDE"; puts(s);
```

| 选项  | 代码示例                           | 主要问题分析                                                 | 输出结果预测                         |
| :---- | :--------------------------------- | :----------------------------------------------------------- | :----------------------------------- |
| **A** | `char s[5]={"ABCDE"};`             | 数组大小**正好为5**，没有空间存放字符串结束符 `\0`。`puts(s)`会**越界读取**内存，直到遇到 `\0`。 | **未定义行为**（通常输出乱码后崩溃） |
| **B** | `char s[5]={'A','B','C','D','E'};` | 这是一个**字符数组**，不是字符串（因**无 `\0`结尾**）。`puts(s)`会越界读取 。 | **未定义行为**（通常输出乱码后崩溃） |
| **C** | `char *s; scanf("%s", s);`         | 指针 `s`**未初始化**，是“野指针”。`scanf`试图将数据写入**未知内存地址**，导致非法写入 。 | **程序崩溃**                         |
| **D** | `char *s; s="ABCDE"; puts(s);`     | **语法正确，能正常输出**。`s`指向字符串常量 `"ABCDE"`（**系统自动添加 `\0`**），这是安全的 。 | **正确输出 ABCDE**                   |

根据题目要求“能使puts(s)语句正确输出ABCDE字符串”，**选项D是唯一正确的选择**。

#### 💡 深入理解与正确方法 ####

虽然D是正确答案，但你的质疑非常有价值。我们来深入探讨一下这些“坑”以及如何正确编写代码。

- **`\0`是字符串的“生命线”**：C语言中的字符串有一个重要约定：**以空字符 `\0`作为结束标志**。`puts`、`printf`等标准库函数都依靠寻找 `\0`来判断字符串在哪里结束。对于A和B选项，由于数组已满，没有空间存放 `\0`，`puts`函数在输出 `'E'`后会继续读取后面的内存字节，并将每个字节当作字符输出，直到“幸运地”遇到某个字节的值恰好为0（即 `\0`）为止。这必然导致**输出乱码**，并且很可能访问到未分配的内存，引起**程序崩溃**。
- **“野指针”的危害**：选项C中的==指针 `s`在定义后没有指向任何有效的内存块，它的值是随机的。==使用 `scanf`向这个随机地址写入数据，就像把重要文件丢进一个随机的邮箱，极有可能覆盖掉程序其他部分的重要数据（如其他变量、代码指令），直接导致程序崩溃。这是非常严重的错误。
- **为什么D选项可行**：语句 `s = "ABCDE";`的含义是，==让指针 `s`指向存储在内存**只读数据区**的字符串常量 `"ABCDE"`。这个字符串常量在编译时就已经创建好了，并且**编译器会自动在末尾添加 `\0`**。==因此，`puts(s)`可以安全地输出。需要注意的是，通过这种方式创建的字符串是**常量，不可修改**。尝试 `s[0] = 'X';`是非法的。



#### 2、教案：涉及字符 / 字符串需注意的点：

​	换行符的处理。作为输入结束的标志（本质是刷新输入缓冲），要注意换行符是否被读取（区别 scanf、gets、fgets）。这段代码希望有助于你们理解：

```c
#include<stdio.h> 
#include<string.h>

void printChar(char c) {
    if(c=='\n')
        printf("LF - %d\n", c);
    else if(c=='\0')
        printf("\'\\0\' - %d\n", c);
    else
        printf("%c - %d\n", c, c);
    return;
}

void printString(char s[]) {
    int i;
    printf("--\n"); 
    for(i=0; i<strlen(s)+1; i++)
        printChar(s[i]);
    printf("--\n"); 
    return;
}

int main() {
    char s[100];
    char c;
    
    // 输入字符串，换行，紧接着输入一个字符，换行 —> 换行符被读取了，但是替换为空字符
    gets(s);
    printString(s);
    c = getchar();
    printChar(c);
    
    // 输入字符串，换行，无需输入字符就会自己蹦出来结果 —> 换行符不读取，停留在输入流中，getchar自动将换行符读取
    scanf("%s", s);
    printString(s);
    c = getchar();
    printChar(c);
    
    // 输入字符串，换行，紧接着输入一个字符，换行 —> 换行符被读取了并且加入到了字符串中，结尾还会再加一个空字符
    fgets(s, 100, stdin);
    printString(s);
    c = getchar();
    printChar(c);
    
    // 输入字符串，无限换行，直至输入非空白字符，换行 —> 多了换行符的格式匹配，无论多少个 \n 都会被读取并丢弃
    scanf("%s\n", s);
    printString(s);
    c = getchar();
    printChar(c);
    
    return 0;
}
```

#### 代码结构解析 ####

首先，我们看看两个辅助函数是做什么的：

- **`printChar`函数**：它的作用是打印一个字符的“真面目”。它会判断字符如果是换行符（`\n`）就显示为 `LF`（Line Feed，换行的意思），如果是字符串结束符（`\0`）就显示为 `\0`，其他普通字符则正常显示。同时，它还会打印出该字符的ASCII码值。这能让我们清楚地看到输入流中到底读到了什么。
- **`printString`函数**：它通过一个循环，遍历字符串数组（从下标`0`到`strlen(s)`），并逐个字符调用`printChar`。**关键点在于**，循环条件是`i < strlen(s)+1`，这意味着它会多打印一个字符，即字符串结束符`\0`。这能让我们直观地看到字符串在内存中是如何正确终止的。

#### 四个输入实验的详解 ####

现在，我们进入最核心的四个实验场景。为了更直观地对比，我们可以将不同函数的关键特性总结如下：

| 函数                     | 是否检查缓冲区边界                 | 遇到空格/制表符          | 遇到换行符 `\n`如何处理              | 是否在末尾自动添加 `\0` | 安全性建议                                   |
| :----------------------- | :--------------------------------- | :----------------------- | :----------------------------------- | :---------------------- | :------------------------------------------- |
| **`gets(s)`**            | ❌ 不检查，非常危险                 | 继续读取，存入字符串     | **读取并丢弃**，替换为 `\0`          | ✔️ 是                    | **已被废弃，绝对避免使用**                   |
| **`scanf("%s", s)`**     | ❌ 不检查（但可用`%99s`等形式限制） | **停止读取**，视为分隔符 | 停止读取，`\n`**留存在输入缓冲区中** | ✔️ 是                    | 读取不含空格的单词时可用，但要注意缓冲区残留 |
| **`fgets(s, n, stdin)`** | ✔️ **是**，通过参数`n`指定，安全    | 继续读取，存入字符串     | **读取并存入**字符串，然后添加 `\0`  | ✔️ 是                    | **推荐使用**，需注意手动处理可能存入的`\n`   |
| **`getchar()`**          | - (每次只读一个字符)               | 正常读取                 | 正常读取                             | -                       | 用于处理单个字符或清空缓冲区                 |

​	接下来，假设我们每次输入的内容都是`"Hello"`然后按下回车（产生换行符`\n`）。

#### 场景一：使用 `gets(s)` ####

- **代码**：`gets(s);`
- **输入示例**：`Hello`+ 回车
- **行为分析**：`gets`会读取`Hello`和换行符，但**它会丢弃换行符，并在末尾自动添加`\0`**。此时输入缓冲区被清空。
- **`printString`输出预测**：`复制-- H - 72 e - 101 l - 108 l - 108 o - 111 '\0' - 0 --`
- **后续`getchar()`**：由于输入缓冲区已空，程序会停下来等待你**输入一个新的字符**（比如输入`A`）。

#### 场景二：使用 `scanf("%s", s)` ####

- **代码**：`scanf("%s", s);`
- **输入示例**：`Hello`+ 回车
- **行为分析**：`scanf`遇到空格、制表符或换行符会停止读取。它只读取`Hello`，并在其后添加`\0`。而那个**换行符`\n`仍然留在了输入缓冲区中**。
- **`printString`输出预测**：与场景一相同，只打印出`Hello`和`\0`。
- **后续`getchar()`**：**关键就在这里！** 它不会等待你输入，而是**直接读取还残留在缓冲区里的那个换行符`\n`**。
- **`printChar`输出预测**：`LF - 10`

#### 场景三：使用 `fgets(s, 100, stdin)` ####

- **代码**：`fgets(s, 100, stdin);`
- **输入示例**：`Hello`+ 回车
- **行为分析**：`fgets`是安全的，它会读取一行，包括换行符。所以它把`Hello`和`\n`都读进来，然后在末尾加`\0`。此时输入缓冲区再次被清空。
- **`printString`输出预测**：`复制-- H - 72 e - 101 l - 108 l - 108 o - 111 LF - 10   // 注意，这里多了一个换行符！ '\0' - 0 --`
- **后续`getchar()`**：缓冲区为空，程序停下来等待你**输入一个新的字符**。

#### 场景四：使用 `scanf("%s\n", s)` ####

- **代码**：`scanf("%s\n", s);`（注意格式字符串里的`\n`）
- **输入示例**：`Hello`+ 回车。但你会发现，按一下回车程序没反应，需要**再输入一些非空白字符（比如`A`），然后再按回车**，程序才会继续。
- **行为分析**：这里的`\n`在格式字符串中不代表一个真正的换行符，而是一个“**读取并丢弃所有空白字符（包括空格、换行符等）的指令**”。所以，`scanf`先读取了`Hello`，然后开始等待输入。你按回车产生的换行符被`\n`匹配并丢弃了，但`\n`的含义是“持续丢弃直到遇到非空白字符”，所以程序会一直等待，直到你输入一个非空白字符（如`A`）并回车。`scanf`读到`A`后，`%s`已经完成，但格式字符串里还有`\n`，它会继续丢弃后面的回车符，然后结束。
- **`printString`输出预测**：只会打印出`Hello`和`\0`。
- **后续`getchar()`**：此时，你最后输入的那个非空白字符（`A`）还留在缓冲区里（因为`\n`格式符丢弃了它后面的回车）。所以`getchar()`会**直接读取这个字符`A`**，而不会等待。
