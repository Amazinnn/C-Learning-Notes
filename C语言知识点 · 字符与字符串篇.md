# C语言知识点 · 字符与字符串篇

## 答疑：

### 1、请你详细说说，printf与putchar与puts有什么异同？

| 特性维度     | `printf`                                   | `putchar`                              | `puts`                             |
| :----------- | :----------------------------------------- | :------------------------------------- | :--------------------------------- |
| **核心功能** | 格式化输出，功能强大                       | 输出**单个**字符                       | 输出**字符串**，并**自动换行**     |
| **输出参数** | 支持多种类型（整数、浮点、字符串等）       | 字符常量、变量或ASCII整数值            | 字符串常量、字符数组名或字符指针   |
| **换行行为** | **不自动换行**，需手动添加 `\n`            | **不自动换行**，需手动添加 `\n`        | **自动在末尾添加换行符** (`\n`)    |
| **返回值**   | 成功时返回输出的**字符总数**               | 成功返回**输出的字符**，失败返回 `EOF` | 成功返回**非负值**，失败返回 `EOF` |
| **性能特点** | 功能全面但开销相对较大（需解析格式字符串） | 最轻量高效，适合处理大量字符           | 简单高效，适合字符串输出           |



###2、%s与%c格式分别支持哪一些输出参数与输入参数？

| 特性维度         | **`%c`(字符格式符)**                                      | **`%s`(字符串格式符)**                                       |
| :--------------- | :-------------------------------------------------------- | :----------------------------------------------------------- |
| **对应数据类型** | `char`                                                    | `char*`(即字符指针) 或 `char[]`(字符数组)                    |
| **输出参数**     | `char`类型的变量、常量或整型值(ASCII码)                   | ==字符数组名、字符指针或字符串常量(代表字符串起始地址)==     |
| **输出行为**     | 输出**单个**字符                                          | 从给定地址开始，输出字符直到遇到**空字符`\0`**               |
| **输入参数**     | **必须**传入`char*`类型，即字符变量的地址(如 `&char_var`) | **必须**传入`char*`类型，通常是字符数组名或已分配内存的指针  |
| **输入行为**     | 读取并存储**下一个**字符(包括空格、换行符)                | 读取字符直到遇到**空白字符**(如空格、换行符)，并自动添加`\0` |



###3、给字符数组赋值时使用字符串初始化，**花括号 `{}`可以省略吗？**

​	在C语言中，给字符数组赋值时，使用字符串初始化，**花括号 `{}`是可以省略的**。所以，即使缺少了 `{}`，代码也是完全正确和常见的写法。

| 初始化场景               | 代码示例                              | 是否**可以**省略 `{}` | 说明与解释                                       |
| :----------------------- | :------------------------------------ | :-------------------- | :----------------------------------------------- |
| **使用字符串常量初始化** | `char str[] = "Hello";`               | **可以**              | 这是C语言标准允许的语法糖，编译器会自动处理。    |
| **使用字符列表初始化**   | `char str[] = {'H','e','l','l','o'};` | **不可以**            | 此时必须使用花括号来明确标识这是一个初始化列表。 |



### 4、请你详细说说，scanf与gets与fgets有什么异同？

​	在C语言中，`scanf`、`gets`和 `fgets`都用于输入，但它们在安全性、处理方式和适用场景上差异很大。为了让你快速掌握核心区别，我准备了一个对比表格，然后我们再深入聊聊细节和使用建议。

| 特性维度            | **`scanf`**                                            | **`gets`(已废弃)**                             | **`fgets`(推荐)**                                          |
| :------------------ | :----------------------------------------------------- | :--------------------------------------------- | :--------------------------------------------------------- |
| **主要功能**        | 格式化输入，读取**单词**                               | 读取整行输入，直到换行符                       | 读取整行输入，或达到指定字符数                             |
| **安全性**          | **较低**，使用`%s`易溢出，需指定宽度（如`%99s`）       | **极低**，**绝对不要使用**，无法防止缓冲区溢出 | **高**，可指定最大读取字符数，有效防止溢出                 |
| **空格/换行符处理** | 遇到**空格、制表符、换行符**即停止读取（当使用`%s`时） | 读取到换行符停止，**丢弃**换行符，自动添加`\0` | 读取到换行符或达到字符数限制停止，**保留**换行符在字符串中 |
| **结束标志**        | 空白字符或根据格式字符串                               | 换行符或EOF                                    | 换行符、EOF或达到指定最大字符数                            |
| **返回值**          | 成功读取并赋值的**数据项个数**                         | 成功返回传入的**指针**，错误或EOF返回`NULL`    | 成功返回传入的**指针**，错误或EOF返回`NULL`                |

#### 🔧 `scanf`：格式化的高手，但需谨慎 ####

​	`scanf`非常适合读取结构规整的数据，比如整数、浮点数或**不包含空格的单个单词**。它的强大在于其格式控制，但也因此更复杂。

- **安全使用`%s`**：直接用`%s`读取字符串非常危险，因为它不知道目标数组的大小。**必须指定字段宽度**来限制读取的最大字符数，这个宽度应比数组长度小1（为字符串结束符`\0`留空间）。

​	`char str[100]; scanf("%99s", str); // 安全：最多读取99个字符`

- **读取带空格的整行**：==如果想用`scanf`读取包含空格的整行文本，可以使用`%[^\n]`格式说明符，它表示读取所有字符直到遇到换行符。==同样需要指定宽度：`scanf("%99[^\n]", str); // 读取一行，直到遇到换行符`

#### ⚠️ `gets`：已被废弃的“陷阱” ####

​	**在任何情况下都不应再使用`gets`函数**。因为它完全不检查目标缓冲区的大小，如果用户输入的数据过长，就会导致**缓冲区溢出**，这可能破坏程序其他数据，甚至被恶意利用执行任意代码。C11标准已将其从语言标准中移除。

#### ✅ `fgets`：安全可靠的选择 ####

​	对于读取字符串，尤其是来自用户输入或文件的整行文本，`fgets`是**最推荐**的方法。

- **处理换行符**：`fgets`会将换行符一同读入字符串。通常我们需要手动移除它：`char str[100]; fgets(str, 100, stdin); // 去除换行符 size_t len = strlen(str); if (len > 0 && str[len-1] == '\n') {    str[len-1] = '\0'; }`



### 5、比较两个字符串是否相等的表达式为（a==b）吗？

在C语言中直接用 `a==b`比较字符串，实际上比较的是两个字符串的**内存地址**，而不是内容本身。正确做法是使用 **strcmp()函数**。



###6、C语言字符串与内存操作函数规范指南

#### 1. 字符串长度计算 ####

##### `strlen` #####

- **原型**：`size_t strlen(const char *str);`
- **功能**：计算字符串长度（不包含结尾的`\0`）。
- **参数**：指向以`\0`结尾的字符串的指针。
- **返回值**：无符号整型（`size_t`），表示字符数。
- **关键注意事项**： 字符串必须以`\0`结束，否则行为未定义。 返回值类型为`size_t`（无符号），进行算术运算时需注意类型转换。
- **示例**： `char str[] = "Hello"; size_t len = strlen(str); // len = 5`

#### 2. 字符串复制函数 ####

##### `strcpy` #####

- **原型**：`char *strcpy(char *dest, const char *src);`
- **功能**：将`src`指向的字符串（包括`\0`）复制到`dest`。
- **参数**： `dest`：目标字符数组的**指针**，需确保空间充足。 `src`：源字符串的**指针**（通常为字符串常量或数组）。
- **返回值**：返回`dest`的指针。
- **风险**：若`dest`空间不足，会导致**缓冲区溢出**。建议使用更安全的`strncpy`。
- **示例**： `char dest[20]; strcpy(dest, "Hello World"); // dest 内容为 "Hello World\0"`

##### `strncpy` #####

- **原型**：`char *strncpy(char *dest, const char *src, size_t n);`
- **功能**：复制`src`的前`n`个字符到`dest`。若`src`长度小于`n`，剩余部分用`\0`填充。
- **注意事项**：若前`n`个字符中无`\0`，则`dest`可能不以`\0`结尾。
- **示例**： `char dest[10]; strncpy(dest, "Hello", 5); // 需手动添加终止符：dest[5] = '\0';`

#### 3. 字符串连接函数 ####

##### `strcat` #####

- **原型**：`char *strcat(char *dest, const char *src);`
- **功能**：将`src`追加到`dest`末尾（覆盖`dest`原有的`\0`，并在新字符串末尾添加`\0`）。
- **参数**：`dest`必须为**字符数组**，且空间需容纳拼接后的结果。
- **返回值**：返回`dest`的指针。
- **示例**： `char dest[20] = "Hello"; strcat(dest, " World"); // dest 变为 "Hello World"`

##### `strncat` #####

- **原型**：`char *strncat(char *dest, const char *src, size_t n);`
- **功能**：追加`src`的前`n`个字符，并在结果末尾自动添加`\0`。
- **安全性**：比`strcat`更安全，建议优先选择。

#### 4. 字符串比较函数 ####

##### `strcmp` #####

- **原型**：`int strcmp(const char *str1, const char *str2);`
- **功能**：按ASCII码逐字符比较两字符串。
- **返回值**： 若`str1 < str2`，返回**负整数**； 若`str1 == str2`，返回`0`； 若`str1 > str2`，返回**正整数**。
- **注意**：**不可用** `==`直接比较字符串（比的是地址），必须用此函数。区分大小写。
- **示例**： `int result = strcmp("apple", "banana"); // 结果 < 0`

##### `strncmp` #####

- **原型**：`int strncmp(const char *str1, const char *str2, size_t n);`
- **功能**：仅比较前`n`个字符。

#### 5. 字符串查找函数 ####

##### `strchr`/ `strrchr` #####

- **原型**： `char *strchr(const char *str, int c);`// 首次出现 `char *strrchr(const char *str, int c);`// 最后一次出现
- **功能**：查找字符`c`在`str`中的位置。
- **返回值**：找到则返回指向该字符的**指针**，否则返回`NULL`。
- **示例**： `char *p = strchr("Hello", 'e'); // p 指向 "ello"`

##### `strstr` #####

- **原型**：`char *strstr(const char *haystack, const char *needle);`
- **功能**：查找子串`needle`在`haystack`中首次出现的位置。
- **返回值**：找到则返回指向子串的**指针**，否则返回`NULL`。
- **示例**： `char *p = strstr("Hello World", "World"); // p 指向 "World"`

#### 6. 内存操作函数（可用于任意数据） ####

##### `memcpy` #####

- **原型**：`void *memcpy(void *dest, const void *src, size_t n);`
- **功能**：从`src`复制`n`字节到`dest`。
- **注意**：不处理内存重叠（重叠时需用`memmove`）。

##### `memmove` #####

- **原型**：`void *memmove(void *dest, const void *src, size_t n);`
- **功能**：安全处理内存重叠的复制（如：将数组前移）。
- **示例**： `char str[] = "Hello"; memmove(str, str + 1, 4); // 结果变为 "ello"`

##### `memset` #####

- **原型**：`void *memset(void *ptr, int value, size_t n);`
- **功能**：将`ptr`开始的`n`字节设置为`value`（通常用于初始化或清零）。
- **示例**： `char buf[10]; memset(buf, 0, sizeof(buf)); // 清零数组`

##### `memcmp` #####

- **原型**：`int memcmp(const void *ptr1, const void *ptr2, size_t n);`
- **功能**：比较`ptr1`和`ptr2`的前`n`字节（按字节比较，不关心`\0`）。
- **与`strcmp`区别**：`memcmp`不检查终止符，比较精确的字节数。

------

#### 通用注意事项表 ####

| 函数类别                          | 关键风险           | 安全实践                                      |
| --------------------------------- | ------------------ | --------------------------------------------- |
| 复制/连接类（`strcpy`, `strcat`） | 缓冲区溢出         | 确保目标空间充足；优先使用`strncpy`/`strncat` |
| 指针类（`strchr`, `strstr`）      | 解引用`NULL`指针   | 检查返回值是否为`NULL`                        |
| 所有函数                          | 字符串未以`\0`结尾 | 确保输入为合法字符串                          |
| 动态内存操作                      | 内存泄漏           | 使用`free`释放`malloc`分配的内存              |

> 提示：
>
> - 使用指针传递字符串时（如`char*`），若字符串不应被修改，建议用`const`修饰（如`const char*`）。
> - 数组与指针在函数参数中基本等价（数组退化为指针），但数组声明需确保空间足够。
> - 推荐使用更安全的带长度限制的函数（如`strncpy`替代`strcpy`）以避免溢出。





### 7、缓冲区没有任何字符时，getchar调用会得到什么？

#### 阻塞并等待输入 ####

​	这是最常见的情况。程序会**暂停执行**（这种状态通常被称为“阻塞”），直到用户在终端上输入内容并按下回车键为止。

​	当用户按下回车后，输入的所有字符（包括回车键产生的换行符 `\n`）会一起被送入输入缓冲区。随后，`getchar()`会从缓冲区中**读取第一个字符**，并将其作为 `int`类型的值（该字符的ASCII码）返回。缓冲区中剩余的字符则等待下一次 `getchar()`调用或其它输入函数读取。

#### 🔚 立即返回EOF ####

​	在某些特定的操作下，即使没有输入任何字符，`getchar()`也会立即返回。这时，它返回的是一个特殊的标志——**EOF** (End Of File)。（或者是文件读取到末尾，譬如说**在线代码评测系统**）

- **如何触发**：在类Unix系统（如Linux、macOS）下，在空输入时按下 `Ctrl + D`组合键；在Windows系统的命令行中，则需按下 `Ctrl + Z`组合键，然后按回车。
- **EOF的值**：EOF通常被定义为 -1。这也就是为什么 `getchar()`的返回值类型是 `int`而不是 `char`——为了能够区分所有有效的字符字节（通常是0到255）和这个特殊的错误/结束标志。



### 8.  当输入缓冲区包含前导空格（如"␣␣␣␣1␣22␣333"）时，多次调用`scanf`会如何工作？ ###

​	关键在于格式说明符对空白符的处理方式：

- **`%d`、`%f`、`%s`**：自动跳过**任意数量**的前导空白符（空格、制表符`\t`、换行符`\n`），读取有效数据，遇下一个空白符停止
- **`%c`**：默认**不跳过**任何前导空白符，直接读取当前字符
- **`%[^\n]`**：读取除换行符外的所有字符，包括空格
- **缓冲区是顺序的**：所有`scanf`调用共享同一个缓冲区，每次从当前位置开始读取

**注意事项**：`scanf`后检查返回值，清空缓冲区残留字符（用`while((c=getchar())!='\n' && c!=EOF);`）。



### 9. 缓冲区为"abc\ndef"时，两个连续的`scanf("%s")`会读取到什么？ ###


| 调用  | 缓冲区状态 | 读取结果 | 原因                              |
| ----- | ---------- | -------- | --------------------------------- |
| 第1次 | `abc\ndef` | `"abc"`  | 遇`\n`停止，`\n`留在缓冲区        |
| 第2次 | `\ndef`    | `"def"`  | 跳过`\n`（前导空白符），遇EOF停止 |

**核心**：`%s`会跳过前导空白符（包括`\n`），遇空白符停止读取，该空白符留在缓冲区。



### 10.`scanf("%[^\n]")`和`scanf("%s")`处理换行符有何不同？ ###

​	根本差异在于读取规则：

| 特性           | `%[^\n]`                           | `%s`                                     |
| -------------- | ---------------------------------- | ---------------------------------------- |
| **工作原理**   | 读取直到`\n`的所有字符（包括空格） | 跳过前导空白符，读取到下一个空白符       |
| **对`\n`处理** | 不读取`\n`，将其留在缓冲区         | 作为停止标志之一，前导时跳过，结束时留下 |
| **读取空格**   | ✅ 可以                             | ❌ 不可以（遇空格停止）                   |
| **典型用途**   | 带空格的整行文本                   | 无空格的单词                             |

**关键点**：使用`%[^\n]`后必须处理缓冲区中残留的`\n`，否则后续输入会出问题。



### 11. `fgets`读取时遇到`\n`但未达指定长度，会怎样？ ###

​	**立即停止读取**，并将`\n`包含在结果字符串中。

**工作机制**：`fgets`按以下顺序满足即停止：

1. 遇到`\n`（换行符）→ 包含`\n`，停止
2. 读取`n-1`个字符 → 不包含`\n`，停止
3. 遇到EOF → 停止

**示例**：`fgets(str, 10, stdin)`读取"abc\ndef"：

- 结果：`"abc\n\0"`（`strlen`为4）
- 缓冲区剩余：`"def"`

**实用技巧**：常需移除末尾的`\n`：

```c
char *pos = strchr(str, '\n');
if(pos) *pos = '\0';
```



### 12. `scanf("%*d", &a)`会发生什么？ ###

​	编译错误**。因为`%*d`中的`*`是**抑制符**，表示"读取但不存储"，所以不应提供变量地址。

**正确用法**：

```c
// 用法1：跳过不需要的数据
scanf("%*d"); // 读取一个整数并丢弃

// 用法2：跳过部分输入
scanf("%*d %d", &a); // 跳过第一个整数，读取第二个到a

// 用法3：跳过格式中的特定部分
scanf("%d-%*d-%d", &year, &day); // 读取年、月、日，但跳过月份
```

**返回值注意**：被跳过的数据不计入`scanf`的成功返回值。



---

##代码实例：

####1、假设`scanf`语句执行时输入`ABCDE`<回车>，能使`puts(s)`语句正确输出`ABCDE`字符串的程序段是__。我感觉四个选项都有点问题？A选项与B选项没有在字符串的末尾添加'\0'，C选项与D选项的s都是野指针。

```c
char s[5]={"ABCDE"}; puts(s);
```

```c
char s[5]={'A', 'B', 'C', 'D', 'E'}; puts(s);
```

```c
char *s; scanf("%s", s); puts(s);    
```

```c
char *s; s="ABCDE"; puts(s);
```

| 选项  | 代码示例                           | 主要问题分析                                                 | 输出结果预测                         |
| :---- | :--------------------------------- | :----------------------------------------------------------- | :----------------------------------- |
| **A** | `char s[5]={"ABCDE"};`             | 数组大小**正好为5**，没有空间存放字符串结束符 `\0`。`puts(s)`会**越界读取**内存，直到遇到 `\0`。 | **未定义行为**（通常输出乱码后崩溃） |
| **B** | `char s[5]={'A','B','C','D','E'};` | 这是一个**字符数组**，不是字符串（因**无 `\0`结尾**）。`puts(s)`会越界读取 。 | **未定义行为**（通常输出乱码后崩溃） |
| **C** | `char *s; scanf("%s", s);`         | 指针 `s`**未初始化**，是“野指针”。`scanf`试图将数据写入**未知内存地址**，导致非法写入 。 | **程序崩溃**                         |
| **D** | `char *s; s="ABCDE"; puts(s);`     | **语法正确，能正常输出**。`s`指向字符串常量 `"ABCDE"`（**系统自动添加 `\0`**），这是安全的 。 | **正确输出 ABCDE**                   |

根据题目要求“能使puts(s)语句正确输出ABCDE字符串”，**选项D是唯一正确的选择**。

#### 💡 深入理解与正确方法 ####

虽然D是正确答案，但你的质疑非常有价值。我们来深入探讨一下这些“坑”以及如何正确编写代码。

- **`\0`是字符串的“生命线”**：C语言中的字符串有一个重要约定：**以空字符 `\0`作为结束标志**。`puts`、`printf`等标准库函数都依靠寻找 `\0`来判断字符串在哪里结束。对于A和B选项，由于数组已满，没有空间存放 `\0`，`puts`函数在输出 `'E'`后会继续读取后面的内存字节，并将每个字节当作字符输出，直到“幸运地”遇到某个字节的值恰好为0（即 `\0`）为止。这必然导致**输出乱码**，并且很可能访问到未分配的内存，引起**程序崩溃**。
- **“野指针”的危害**：选项C中的==指针 `s`在定义后没有指向任何有效的内存块，它的值是随机的。==使用 `scanf`向这个随机地址写入数据，就像把重要文件丢进一个随机的邮箱，极有可能覆盖掉程序其他部分的重要数据（如其他变量、代码指令），直接导致程序崩溃。这是非常严重的错误。
- **为什么D选项可行**：语句 `s = "ABCDE";`的含义是，==让指针 `s`指向存储在内存**只读数据区**的字符串常量 `"ABCDE"`。这个字符串常量在编译时就已经创建好了，并且**编译器会自动在末尾添加 `\0`**。==因此，`puts(s)`可以安全地输出。需要注意的是，通过这种方式创建的字符串是**常量，不可修改**。尝试 `s[0] = 'X';`是非法的。



### 2、教案：涉及字符 / 字符串需注意的知识点：

​	换行符的处理。作为输入结束的标志（本质是刷新输入缓冲），要注意换行符是否被读取（区别 scanf、gets、fgets）。这段代码希望有助于你们理解：

```c
#include<stdio.h> 
#include<string.h>

void printChar(char c) {
    if(c=='\n')
        printf("LF - %d\n", c);
    else if(c=='\0')
        printf("\'\\0\' - %d\n", c);
    else
        printf("%c - %d\n", c, c);
    return;
}

void printString(char s[]) {
    int i;
    printf("--\n"); 
    for(i=0; i<strlen(s)+1; i++)
        printChar(s[i]);
    printf("--\n"); 
    return;
}

int main() {
    char s[100];
    char c;
    
    // 输入字符串，换行，紧接着输入一个字符，换行 —> 换行符被读取了，但是替换为空字符
    gets(s);
    printString(s);
    c = getchar();
    printChar(c);
    
    // 输入字符串，换行，无需输入字符就会自己蹦出来结果 —> 换行符不读取，停留在输入流中，getchar自动将换行符读取
    scanf("%s", s);
    printString(s);
    c = getchar();
    printChar(c);
    
    // 输入字符串，换行，紧接着输入一个字符，换行 —> 换行符被读取了并且加入到了字符串中，结尾还会再加一个空字符
    fgets(s, 100, stdin);
    printString(s);
    c = getchar();
    printChar(c);
    
    // 输入字符串，无限换行，直至输入非空白字符，换行 —> 多了换行符的格式匹配，无论多少个 \n 都会被读取并丢弃
    scanf("%s\n", s);
    printString(s);
    c = getchar();
    printChar(c);
    
    return 0;
}
```

#### 代码结构解析 ####

首先，我们看看两个辅助函数是做什么的：

- **`printChar`函数**：它的作用是打印一个字符的“真面目”。它会判断字符如果是换行符（`\n`）就显示为 `LF`（Line Feed，换行的意思），如果是字符串结束符（`\0`）就显示为 `\0`，其他普通字符则正常显示。同时，它还会打印出该字符的ASCII码值。这能让我们清楚地看到输入流中到底读到了什么。
- **`printString`函数**：它通过一个循环，遍历字符串数组（从下标`0`到`strlen(s)`），并逐个字符调用`printChar`。**关键点在于**，循环条件是`i < strlen(s)+1`，这意味着它会多打印一个字符，即字符串结束符`\0`。这能让我们直观地看到字符串在内存中是如何正确终止的。

#### 四个输入实验的详解 ####

现在，我们进入最核心的四个实验场景。为了更直观地对比，我们可以将不同函数的关键特性总结如下：

| 函数                     | 是否检查缓冲区边界                 | 遇到空格/制表符          | 遇到换行符 `\n`如何处理              | 是否在末尾自动添加 `\0` | 安全性建议                                   |
| :----------------------- | :--------------------------------- | :----------------------- | :----------------------------------- | :---------------------- | :------------------------------------------- |
| **`gets(s)`**            | ❌ 不检查，非常危险                 | 继续读取，存入字符串     | **读取并丢弃**，替换为 `\0`          | ✔️ 是                    | **已被废弃，绝对避免使用**                   |
| **`scanf("%s", s)`**     | ❌ 不检查（但可用`%99s`等形式限制） | **停止读取**，视为分隔符 | 停止读取，`\n`**留存在输入缓冲区中** | ✔️ 是                    | 读取不含空格的单词时可用，但要注意缓冲区残留 |
| **`fgets(s, n, stdin)`** | ✔️ **是**，通过参数`n`指定，安全    | 继续读取，存入字符串     | **读取并存入**字符串，然后添加 `\0`  | ✔️ 是                    | **推荐使用**，需注意手动处理可能存入的`\n`   |
| **`getchar()`**          | - (每次只读一个字符)               | 正常读取                 | 正常读取                             | -                       | 用于处理单个字符或清空缓冲区                 |

​	接下来，假设我们每次输入的内容都是`"Hello"`然后按下回车（产生换行符`\n`）。

#### 场景一：使用 `gets(s)` ####

- **代码**：`gets(s);`
- **输入示例**：`Hello`+ 回车
- **行为分析**：`gets`会读取`Hello`和换行符，但**它会丢弃换行符，并在末尾自动添加`\0`**。此时输入缓冲区被清空。
- **`printString`输出预测**：`复制-- H - 72 e - 101 l - 108 l - 108 o - 111 '\0' - 0 --`
- **后续`getchar()`**：由于输入缓冲区已空，程序会停下来等待你**输入一个新的字符**（比如输入`A`）。

#### 场景二：使用 `scanf("%s", s)` ####

- **代码**：`scanf("%s", s);`
- **输入示例**：`Hello`+ 回车
- **行为分析**：`scanf`遇到空格、制表符或换行符会停止读取。它只读取`Hello`，并在其后添加`\0`。而那个**换行符`\n`仍然留在了输入缓冲区中**。
- **`printString`输出预测**：与场景一相同，只打印出`Hello`和`\0`。
- **后续`getchar()`**：**关键就在这里！** 它不会等待你输入，而是**直接读取还残留在缓冲区里的那个换行符`\n`**。
- **`printChar`输出预测**：`LF - 10`

#### 场景三：使用 `fgets(s, 100, stdin)` ####

- **代码**：`fgets(s, 100, stdin);`
- **输入示例**：`Hello`+ 回车
- **行为分析**：`fgets`是安全的，它会读取一行，包括换行符。所以它把`Hello`和`\n`都读进来，然后在末尾加`\0`。此时输入缓冲区再次被清空。
- **`printString`输出预测**：`复制-- H - 72 e - 101 l - 108 l - 108 o - 111 LF - 10   // 注意，这里多了一个换行符！ '\0' - 0 --`
- **后续`getchar()`**：缓冲区为空，程序停下来等待你**输入一个新的字符**。

#### 场景四：使用 `scanf("%s\n", s)` ####

- **代码**：`scanf("%s\n", s);`（注意格式字符串里的`\n`）
- **输入示例**：`Hello`+ 回车。但你会发现，按一下回车程序没反应，需要**再输入一些非空白字符（比如`A`），然后再按回车**，程序才会继续。
- **行为分析**：这里的`\n`在格式字符串中不代表一个真正的换行符，而是一个“**读取并丢弃所有空白字符（包括空格、换行符等）的指令**”。所以，`scanf`先读取了`Hello`，然后开始等待输入。你按回车产生的换行符被`\n`匹配并丢弃了，但`\n`的含义是“持续丢弃直到遇到非空白字符”，所以程序会一直等待，直到你输入一个非空白字符（如`A`）并回车。`scanf`读到`A`后，`%s`已经完成，但格式字符串里还有`\n`，它会继续丢弃后面的回车符，然后结束。
- **`printString`输出预测**：只会打印出`Hello`和`\0`。
- **后续`getchar()`**：此时，你最后输入的那个非空白字符（`A`）还留在缓冲区里（因为`\n`格式符丢弃了它后面的回车）。所以`getchar()`会**直接读取这个字符`A`**，而不会等待。



