

# C语言学习 · 初识指针篇

##答疑：

### **1、正确的Swap函数在做什么？** ###

你所说的那个正确的 `swap`函数，典型写法是这样的：

```
void swap(int *p1, int *p2) {
    int temp = *p1; // 获取p1指向的值
    *p1 = *p2;     // 将p2指向的值赋给p1指向的内存单元
    *p2 = temp;    // 将暂存的值赋给p2指向的内存单元
}
```

这个函数的工作过程是这样的：

1. **传递的是地址副本**：当你调用 `swap(&a, &b)`时，函数形参 `p1`和 `p2`接收到的是 `a`和 `b`的地址的**副本**。
2. **操作的是地址指向的值**：函数内部通过 `*`（解引用）操作符，直接访问 `p1`和 `p2`所指向的内存单元（也就是变量 `a`和 `b`所在的地方），并交换这两个内存单元里的**数据**。
3. **指针的指向从未改变**：在整个过程中，`p1`始终指向变量 `a`的地址，`p2`始终指向变量 `b`的地址。改变的是它们“家里”的“布置”（变量的值），而不是它们的“家门牌号”（指针的指向）。

​	所以，关键在于区分两个概念：

- **改变指针的指向**：即让指针变量存储另一个地址。在函数调用中，单纯改变形参指针的指向是无效的。
- **改变指针所指向的值**：即通过解引用操作，修改指针所指向的内存地址中存储的数据。这才是正确 `swap`函数的原理。

​	简单来说就是：**正确的swap函数交换的是“值”，而不是“地址”**。指针就像一个忠诚的向导，自始至终指向同一个地方，但函数通过这个向导把那个地方存放的宝物成功调包了！==PS：因此，使用指针变量，能将多个运算结果返回主调函数！==



### 2、指针和数组有哪些异同？

​	理解指针和数组的异同确实是掌握C语言的关键。为了让你一目了然，我们先通过下面这个表格来梳理它们的核心区别，然后再解释一些重要的关联和细节。

| 特性             | 数组                                                         | 指针                                                         |
| :--------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| **本质**         | 一段**连续的内存块**，用于存储多个相同类型的数据             | 一个**变量**，其值是另一个变量的内存地址                     |
| **内存占用**     | 所有元素占用的内存总和（如 `int arr[5]`占用 20 字节）        | 固定大小（4字节或8字节，取决于系统位数）                     |
| **身份/可改性**  | 数组名是**常量**，代表一块固定内存的起始地址，不可被重新赋值 | 指针是**变量**，其存储的地址可以被改变，从而指向不同的内存单元 |
| **`sizeof`操作** | 返回整个数组所占的字节总数                                   | 返回指针变量本身所占的字节数（地址长度）                     |
| **赋值操作**     | 不能直接赋值（如 `arr1 = arr2`是错误的）                     | 可以相互赋值（如 `ptr1 = ptr2`是合法的）                     |
| **支持运算**     | 数组名不支持自增(++)、自减(--)等运算                         | 指针支持算术运算（如++, --, +, -），用于移动指向的位置       |
| **内存分配**     | 通常在编译时静态确定（如栈上分配）                           | 可以动态分配和释放（如使用 `malloc`和 `free`）               |

#### 🔗 重要的联系与共同点 ####

​	尽管有上述区别，指针和数组在C语言中关系非常密切，这也是它们容易混淆的原因：

1. **访问方式的相似性**：两者都支持使用下标运算符 `[]`和间接寻址运算符 `*`来访问元素。例如，`arr[i]`和 `*(ptr + i)`是等价的。
2. **数组名的“退化”**：在大多数表达式中，数组名会被编译器自动转换为指向其首元素的指针。例如，当我们将数组 `arr`传递给一个函数时，函数内部接收到的是一个指针，而不是整个数组的副本。这就是为什么在函数内部无法用 `sizeof(arr)`来获取数组实际长度的原因。
3. **作为函数参数**：当数组作为函数参数时，它完全等价于一个指针。`void func(int arr[])`和 `void func(int *arr)`是两种完全等价的写法。

#### ⚠️ 常见误区与注意事项 ####

1. **函数参数退化**：这是最常见的陷阱。在函数内部，对数组参数使用 `sizeof`得到的是指针的大小，而不是原数组的大小。因此，通常需要额外传递一个参数来表示数组长度。
2. **`&arr`与 `arr`**：虽然它们的值（地址）相同，但类型不同。`arr`是首元素的地址（类型为 `int*`），而 `&arr`是整个数组的地址（类型为 `int(*)[5]`）。对后者进行指针运算（如+1）会跳过整个数组的长度。
3. **指针数组 vs 数组指针**：**指针数组**：本质是数组，数组里存放的是指针。例如 `int *ptr_arr[10]`。**数组指针**：本质是指针，指向一个数组。例如 `int (*arr_ptr)[10]`。



###3、如何理解“数组的形参a是一个指针”？

​	当数组作为函数参数时，为了**避免拷贝整个数组带来的巨大开销**，C语言直接传递数组的**首地址**。因此，形参形式上写的虽然是数组（如 `int a[]`），但编译器会将其视为一个**指针变量**（如 `int *a`）来处理。

#### 📌 核心要点速览 ####

| 对比维度     | 普通变量形参 (如 `int a`)                    | 数组作为形参 (如 `int a[]`)                                  |
| :----------- | :------------------------------------------- | :----------------------------------------------------------- |
| **传递机制** | **值传递**：传递的是变量值的副本。           | **地址传递**：传递的是数组首元素的地址。                     |
| **操作影响** | 函数内修改形参，**不影响**实参。             | 通过地址直接操作原数组内存，函数内修改**直接影响**实参。     |
| **内存占用** | 占用变量类型本身的大小（如int通常为4字节）。 | 形参退化为指针，仅占用一个指针的大小（通常4或8字节）。       |
| **长度信息** | 不涉及。                                     | **丢失**。在函数内 `sizeof(a)`得到的是指针大小，而非数组长度，必须额外传递长度参数。 |

#### ⚠️ 最重要的实践提醒 ####

​	在函数内部，**无法通过 `sizeof(a) / sizeof(a[0])`来获取数组长度**，因为此时的 `a`已是指针。数组的长度信息必须在调用函数时作为另一个参数显式传递进去。



###4、一维、二维数组作为参数传递给函数时，有哪几种写法？

​	在C语言中，将数组传递给函数是一个核心概念，其本质是**传递数组的首地址**，而非整个数组的拷贝，因此函数内对数组元素的修改会直接影响原数组。下面我们详细探讨一维和二维数组作为函数参数的写法。

#### 📝 一维数组作为函数参数 ####

​	一维数组作为参数时，形参主要有以下三种等效的声明方式：

1. **指针形式**：`void func(int *arr, int size)`这是最本质的形式。`arr`是一个指针，直接接收数组的首地址。在函数内部，既可以用指针算术 `*(arr + i)`访问元素，也可以用下标形式 `arr[i]`。

2. **未指定大小的数组**：`void func(int arr[], int size)`这是最常见的形式之一。虽然形参写成了数组样式，但编译器会将其视为指针。方括号 `[]`仅起示意作用，其中的数字可以被忽略。

3. **已指定大小的数组**：`void func(int arr[10], int size)`这种写法指定了数组大小，但请注意，这个数字（例如10）**通常会被编译器忽略**。它只是对程序员的一个提示，函数内部不应依赖这个值进行边界检查，实际的数组操作范围仍应由 `size`参数控制。

   **关键注意事项**：

4. **必须传递数组长度**：由于数组在函数内退化为指针，使用 `sizeof(arr)`得到的是指针的大小，而非数组的总大小。因此，必须额外传递一个参数 `size`来指明数组的实际长度。

5. **函数调用**：调用函数时，只需传入数组名（即首地址）和长度即可：`func(my_array, my_size);`。

#### 📊 二维数组作为函数参数 ####

​	二维数组在内存中也是按行连续排列的，但传递方式更为复杂，因为需要让函数知道每一行有多少元素（列数），才能正确计算元素的偏移地址。主要有以下两种标准写法：

1. **指定列数的二维数组**：`void func(int arr[][COL], int rows)`这是最直观和推荐的方法。**第二维（列数）必须明确指定**，且要与实参的列数一致。第一维的大小可以省略，由 `rows`参数指定。
2. **数组指针**：`void func(int (*arr)[COL], int rows)`这种写法与第一种完全等价。`arr`是一个指针，它指向一个长度为 `COL`的一维数组。在函数内部，可以使用 `arr[i][j]`的方式访问元素。

**对于动态或列数不定的二维数组**，可以将其视为一维数组进行指针操作：

​	**单指针+手动计算偏移**：`void func(int *arr, int rows, int cols)`将二维数组的首地址 (`&array[0][0]`或 `(int*)array`) 作为一维指针传入。在函数内部，通过 `*(arr + i * cols + j)`来访问 `array[i][j]`。



### 5、可以用一个指针变量指向一个函数，然后通过该指针变量调用此函数吗？

​	在C语言中，函数指针正是用来实现这个功能的。它允许你将一个函数的地址赋给一个指针变量，然后通过这个指针变量来调用它指向的函数。

1. ### 函数指针的基本用法 ###

   ​	函数指针的使用主要包含三个步骤：**定义指针变量**、**让指针指向函数**、**通过指针调用函数**。

   1. **定义函数指针变量**函数指针变量的定义语法看起来有点特别，需要你细心留意：`返回类型 (*指针变量名)(参数类型列表);`例如，要定义一个指向“返回`int`类型、并接受两个`int`类型参数”的函数的指针，可以这样写：`int (*p)(int, int); // 定义指向函数的指针变量p`这里的括号`(*p)`是必须的，它表明`p`首先是一个指针，然后指向一个函数。如果写成`int *p(int, int);`，编译器会认为`p`是一个返回`int*`类型（整型指针）的函数，这就完全不一样了。
   2. **让指针指向函数**让指针指向一个函数非常简单，只需要将函数名赋给指针变量即可：`p = max; // 假设max是一个符合类型的函数，使p指向max函数`这里，函数名`max`就代表了该函数在内存中的起始地址（入口地址）。你也可以写成`p = &max;`，两种写法是等价的，但通常省略`&`的写法更常见。
   3. **通过指针调用函数**通过函数指针调用它所指向的函数，也有两种等效的方式：`c = (*p)(a, b); // 方式一：使用解引用操作符 c = p(a, b);    // 方式二：直接使用指针变量名（更简洁的现代风格）`这两种方式都能成功调用`p`指向的函数，效果与直接写`c = max(a, b);`完全相同。



### 6、不同类型的指针变量是可以直接相互赋值的吗？

​	在C/C++中，不同类型的指针变量不能直接相互赋值，编译器通常会报错。

​	`void*`是一种特殊的指针类型，它可以存放任何类型对象的地址，被称为“无类型指针”。你可以将任何指针直接赋值给`void*`指针，反之则**必须**进行强制类型转换。



###7、有两个间接取值运算符是什么意思？

​	两个间接取值运算符（`**`）表示您正在使用一个**二级指针**。`**pp`的意思是：先通过 `*pp`取得它指向的那个一级指针（也就是 `p`），然后再通过一次解引用 `*(*pp)`来获取这个一级指针所指向的整数值（也就是数组中的元素）。

| 概念                | 对应代码示例 (接上表变量)      | 含义解释                                                     |
| :------------------ | :----------------------------- | :----------------------------------------------------------- |
| 二级指针 (`pp`)     | `int **pp = &p;`               | 存储一级指针 `p`的地址。                                     |
| 一级解引用 (`*pp`)  | `*pp`（等价于 `p`)             | 获取 `pp`所指向的指针变量（即 `p`）的内容，也就是变量 `a`的地址。 |
| 二级解引用 (`**pp`) | `**pp`（等价于 `*p`等价于 `a`) | 先通过 `*pp`找到 `p`，再通过 `*p`找到 `a`，从而访问或修改变量 `a`的值。 |



### 8、若有定义 double *p;，使p指向一个双精度型的动态存储单元的语句为（）。  

```c
A. p = malloc(sizeof(double));
B. p = (double *)malloc(sizeof(*p));
C. p = malloc(8);
D. p = (double *)malloc(sizeof(double));
```

| 选项 | 代码                                    | 正确性 | 关键分析                                                     |
| :--- | :-------------------------------------- | :----- | :----------------------------------------------------------- |
| A    | `p = malloc(sizeof(double));`           | ❌      | 缺少对`malloc`返回值的强制类型转换（`void*`到 `double*`）。在C++中会报错，虽然C语言允许隐式转换，但显式转换是更良好的编程习惯。 |
| B    | `p = (double *)malloc(sizeof(*p));`     | ✅      | **正确**。`sizeof(*p)`等价于 `sizeof(double)`，因为`p`是`double*`类型，解引用`*p`就是`double`类型。此写法灵活且不易出错。 |
| C    | `p = malloc(8);`                        | ❌      | 直接使用魔数`8`而非`sizeof`操作符。不同平台下`double`类型所占字节数可能不同，此写法不利于移植，且同样缺少类型转换。 |
| D    | `p = (double *)malloc(sizeof(double));` | ✅      | **正确**。标准写法，既进行了强制类型转换，又使用`sizeof`计算了准确的数据类型大小。 |



### 9、



###10、下面程序段的运行结果是：___________________ 。
```c
char s[20]= "abcd" ; 
char *sp = s ;
puts(strcat(sp+1, "ABCD"+1)) ;
```

​	`strcat(sp+1, "ABCD"+1)`是代码的关键。

- **第一个参数 `sp+1`**：`sp`指向 `s[0]`，所以 `sp+1`指向 `s[1]`（字符 `'b'`）。从 `s[1]`开始的字符串是 `"bcd"`（因为其后有 `s[2]='c'`, `s[3]='d'`, `s[4]='\0'`）。
- **第二个参数 `"ABCD"+1`**：`"ABCD"`是字符串常量，在内存中为 `'A'`, `'B'`, `'C'`, `'D'`, `'\0'`。`"ABCD"+1`是指针运算，指向该字符串的第二个字符 `'B'`，因此实际代表字符串 `"BCD"`（从 `'B'`开始到结束符）。



### 11、指针所占内存的大小由其指向的数据类型的大小决定吗？

​	**指针本身是一个变量，它存储的是内存地址，而不是实际的数据。**指针在内存中占用的空间大小取决于系统的架构，而不是它指向的数据类型的大小。

​	在32位系统中，指针通常占用4字节。在64位系统中，指针通常占用8字节。这意味着，无论指针指向的是int、double还是其他数据类型，指针本身的大小是固定的，由系统的地址总线宽度决定。因此，题目的陈述是错误的。



###12、指针之间可以进行加减和比较大小吗？

​	在C语言中，指针之间的运算是有特定规则的。简单来说，指针之间可以进行比较运算，也可以进行减法运算，但**不能进行加法运算**。

| 运算类型                           | 是否允许     | 核心规则                                           | 有意义的前提条件                                       |
| :--------------------------------- | :----------- | :------------------------------------------------- | :----------------------------------------------------- |
| **比较运算**(>, <, >=, <=, ==, !=) | ✅ **允许**   | 比较的是内存地址的高低。                           | 通常要求两个指针指向**同一个连续的内存块**（如数组）。 |
| **减法运算**                       | ✅ **允许**   | 结果是两个地址之间相隔的**元素个数**，而非字节数。 | 两个指针必须指向**同一个数组**。                       |
| **加法运算**                       | ❌ **不允许** | 两个指针相加没有语义意义，会导致编译错误。         | 无                                                     |

#### 💡 深入理解指针运算 ####

- **指针的减法**：其结果是 `ptrdiff_t`类型的整数，代表两个指针之间能存放多少个这种类型的元素。计算时会自动考虑数据类型的大小，例如，一个`int`通常占4字节，若两指针地址相差8字节，相减结果便是2个元素。
- **指针的比较**：最常见的应用是在遍历数组时进行边界检查。通过比较当前指针和数组末尾之后的位置，可以防止越界。但需注意，比较指向**不同数组**或**不相关对象**的指针，其结果是**未定义行为**。

#### ⚠️ 重要注意事项 ####

1. **避免未定义行为**：确保指针比较和减法运算只在有明确意义的范围内进行，例如在同一个数组或同一块动态分配的内存内部。
2. **`void\*`指针的限制**：`void*`是通用指针，可以指向任何数据类型，但因为编译器不知道它指向的数据类型大小（“步长”），所以**不能**进行 `p+1`或 `p++`这样的算术运算。在进行比较前，通常需要先强制转换为具体的指针类型。



###13、可以这样写吗：`p=(int *)realloc(p,n*sizeof(int)); `

​	直接使用 `p = (int *)realloc(p, n * sizeof(int));`这种写法是**不安全**的。虽然语法上没有错误，但在实际编程中，这种做法存在一个明显的风险，可能会导致内存泄漏。

| 特性         | 不安全写法 (`p = realloc(p, ...)`)          | 推荐的安全做法 (使用临时指针)                                |
| :----------- | :------------------------------------------ | :----------------------------------------------------------- |
| **核心问题** | 内存泄漏风险                                | 保持原内存块安全                                             |
| **情景**     | 当`realloc`分配失败返回`NULL`时             | 先检查临时指针，成功后再赋值                                 |
| **后果**     | 原指针`p`丢失，原内存块无法被访问也无法释放 | 原指针`p`始终有效，可正常释放或进行其他处理                  |
| **代码示例** | `p = (int *)realloc(p, n * sizeof(int));`   | `int *temp = (int *)realloc(p, n * sizeof(int));` `if (temp != NULL) { p = temp; }` |

#### 💡 理解realloc的行为 ####

​	要理解为什么上面的写法不安全，关键是要知道`realloc`函数在无法满足扩大内存的请求时可能会返回`NULL`，但此时**原来`p`指向的那块内存依然存在**，需要你之后去释放。

​	如果你直接 `p = realloc(p, ...);`并且`realloc`失败返回了`NULL`，那么这个`NULL`值就覆盖了`p`原先的值。结果是，你不仅没有获得新的更大内存，还**丢失了**指向原来那块内存的“地址”，导致原来那块内存无法被访问也无法被释放，这就造成了“内存泄漏”。

#### 🛠️ 正确的使用步骤 ####

安全的使用方法通常包含以下几步：

1. **使用临时指针**：用一个临时指针（比如`temp`）来接收`realloc`的返回值。
2. **检查是否成功**：判断临时指针是否为`NULL`。
3. **赋值**：如果临时指针非`NULL`（代表分配成功），再将这个新指针赋值给原指针`p`。
4. **处理失败**：如果临时指针为`NULL`，说明分配失败。你需要决定如何处理，比如报错并安全地使用原来的内存块，或者进行其他清理工作。

```c
#include <stdlib.h>

int main() {
    // 假设p已经指向一块动态分配的内存
    int *p = (int *)malloc(10 * sizeof(int));
    if (p == NULL) {
        // 处理初始分配失败
        return -1;
    }

    // 需要调整内存大小
    int n = 20;
    int *temp = (int *)realloc(p, n * sizeof(int)); // 使用临时指针

    if (temp != NULL) {
        // 重新分配成功，将新地址赋给p
        p = temp;
    } else {
        // 重新分配失败！但原来的内存块（p指向的）仍然存在
        // 可以进行错误处理，例如输出信息，并保证p指向的内存仍可使用/释放
        // 这里选择释放原内存后退出
        free(p);
        p = NULL;
        return -1;
    }

    // ... 使用扩大后的内存

    free(p); // 最后记得释放内存
    p = NULL;
    return 0;
}
```

#### 📝 补充注意事项 ####

- **指针可能移动**：`realloc`可能会在内存中**找一块新的足够大的区域，把旧数据复制过去，然后释放旧内存块。**所以**成功调用`realloc`后，原来指针`p`就不应再直接使用**，而应该使用返回的新指针（可能和原指针相同，也可能是新地址）。这也是为什么使用临时指针能避免混淆。
- **新内存未初始化**：如果`realloc`扩大了内存，新增加的那部分内存空间的内容是**未初始化**的，可能包含任意值。
- **缩小内存**：当使用`realloc`缩小内存块时，超出新尺寸的数据可能会丢失。

---

## 代码实例：



####1、我不太明白这个程序。明明修改的是q指针指向的地址，哪里修改line数组了？

```c
/*压缩字符串中的相邻若干个重复字母*/
#include <stdio.h>
#define MAXLINE 80
void zip(char *p);
int main(void)
{
	char line[MAXLINE];
	printf("Input the string:");
	gets(line);
	zip(line);
	puts(line);
	return 0;
}
void zip(char *p)
{
	char *q=p;
	int n;
	while (*p!='\0'){
		n=1;
		while (*p==*(p+n)){
			n++;
		}
		if (n>=10){
			*q++=(n/10)+'0';
			*q++=(n%10)+'0';
		}
		else if (n>=2){
			*q++=n+'0';
		}
		*q++=*(p+n-1);
		p=p+n;
	}
	*q='\0';
}
```

​	你提出的这个问题非常关键，它触及C语言指针传参的核心概念——**“传递地址，共享内存”**。这个程序之所以能修改`line`数组，正是因为`zip`函数中的指针`q`和`p`从一开始就指向`main`函数中`line`数组的同一块内存地址。

#### ✨ 核心原理：指针与内存共享 ####

​	程序的奥秘就在于 `main`函数中的 `line`数组和 `zip`函数中的 `p`、`q`指针之间的关系：

- 当你在 `main`函数中调用 `zip(line)`时，你传递的是数组 `line`的**首地址**。这意味着函数内部的形参指针 `p`接收到了 `line[0]`的内存地址 。
- 紧接着，在 `zip`函数内，语句 `char *q = p;`让指针 `q`也指向了完全相同的起始位置。
- 因此，后续所有通过 `*q++ = ...`进行的操作，都不是在操作某个“副本”，而是**直接对 `line`数组原始内存空间进行覆盖写入**。这就是所谓的“双向传递”或“地址传递”，函数内部对指针所指内容的修改会直接反映到调用者的原始数据上 。