# C语言知识点·入门篇

## 基础知识：

### 1、 C语言运算符优先级与结合性 ###

下面的表格将运算符分为几个核心组，方便你理解和记忆。记住一个大原则：**在同一个表达式中，优先级高的运算符先计算；优先级相同时，则看它们的结合性（从左到右还是从右到左）**。

| 优先级组别            | 运算符示例                                                   | 主要类别                   | 结合性         |
| :-------------------- | :----------------------------------------------------------- | :------------------------- | :------------- |
| **第1组：最高优先级** | `()` `[]` `->` **`.`**  `++`(后缀) `--`(后缀)                | 括号、成员访问、后缀运算符 | **从左到右**   |
| **第2组：单目运算符** | `!` `~` `++`(前缀) `--`(前缀)  `+`(正) `-`(负) `(type)`  `*`(解引用) `&`(取地址) `sizeof` | 一元运算符                 | **从右到左** ⚠️ |
| **第3组：算术运算**   | `*` `/` `%` `+` `-`                                          | 乘除取模  加减             | 从左到右       |
| **第4组：移位运算**   | `<<` `>>`                                                    | 左移、右移                 | 从左到右       |
| **第5组：关系比较**   | `<` `<=` `>` `>=` `==` `!=`                                  | 大小比较  相等判断         | 从左到右       |
| **第6组：位运算**     | `&` `^` `|`                                                  | 按位与  按位异或  按位或   | 从左到右       |
| **第7组：逻辑运算**   | `&&` `||`                                                    | 逻辑与  逻辑或             | 从左到右       |
| **第8组：条件与赋值** | `  ? :  ` `=` `+=` `-=` `*=` `/=` `%=`等                     | 条件运算符  赋值运算符     | **从右到左** ⚠️ |
| **第9组：逗号运算**   | `,`                                                          | 逗号运算符                 | 从左到右       |



###2、C语言有哪一些关键字？

C语言的关键字随着标准的发展而增加。不同标准下的关键字数量如下表所示：

| 标准版本    | 发布年份  | 关键字数量 | 说明                                  |
| ----------- | --------- | ---------- | ------------------------------------- |
| **C89/C90** | 1989/1990 | 32个       | C语言的第一个标准，定义了核心关键字。 |
| **C99**     | 1999      | 增加5个    | 引入了布尔、复数类型等新特性。        |
| **C11**     | 2011      | 增加7个    | 增强了对多线程编程和泛型的支持。      |
| **C17/C18** | 2018      | 0个        | 未新增关键字，主要是修正C11中的缺陷。 |

#### **C89/C90 标准关键字 (32个)** ####

这32个关键字构成了C语言最核心的基础。

| 关键字         | 类别     | 简要说明                       |
| -------------- | -------- | ------------------------------ |
| `auto`         | 存储类别 | 声明自动变量（通常可省略）     |
| `break`        | 流程控制 | 跳出当前循环或`switch`语句     |
| `case`         | 流程控制 | 定义`switch`语句中的分支       |
| `char`         | 数据类型 | 声明字符型变量                 |
| `const`        | 类型限定 | 声明只读变量（常量）           |
| `continue`     | 流程控制 | 结束本次循环，开始下一次循环   |
| `default`      | 流程控制 | 定义`switch`语句中的默认分支   |
| `do`           | 流程控制 | 循环语句的循环体               |
| `double`       | 数据类型 | 声明双精度浮点型变量           |
| `else`         | 流程控制 | 条件语句的否定分支             |
| **`enum`**     | 数据类型 | 声明枚举类型                   |
| **`extern`**   | 存储类别 | 声明外部全局变量或函数         |
| `float`        | 数据类型 | 声明单精度浮点型变量           |
| `for`          | 流程控制 | 循环语句                       |
| `goto`         | 流程控制 | 无条件跳转语句                 |
| `if`           | 流程控制 | 条件语句                       |
| `int`          | 数据类型 | 声明整型变量                   |
| **`long`**     | 类型修饰 | 修饰整型或双精度浮点型         |
| **`register`** | 存储类别 | 建议编译器将变量存储在寄存器中 |
| `return`       | 流程控制 | 从函数返回                     |
| **`short`**    | 类型修饰 | 修饰整型，短整型               |
| **`signed`**   | 类型修饰 | 声明有符号类型                 |
| **`sizeof`**   | 运算符   | 计算类型或对象所占内存大小     |
| `static`       | 存储类别 | 声明静态变量                   |
| `struct`       | 数据类型 | 声明结构体类型                 |
| `switch`       | 流程控制 | 开关语句（多重分支）           |
| `typedef`      | 其他     | 为数据类型定义别名             |
| `union`        | 数据类型 | 声明共用体类型                 |
| **`unsigned`** | 类型修饰 | 声明无符号类型                 |
| `void`         | 数据类型 | 表示无类型，用于函数或指针     |
| **`volatile`** | 类型限定 | 表示变量可能被意外改变         |
| `while`        | 流程控制 | 循环语句的循环条件             |

#### **C99 标准新增关键字 (5个)** ####

| 关键字       | 简要说明                                                 |
| ------------ | -------------------------------------------------------- |
| `_Bool`      | 布尔类型，只能取值0或1                                   |
| `_Complex`   | 复数类型                                                 |
| `_Imaginary` | 虚数类型                                                 |
| `inline`     | 建议编译器将函数内联展开以优化效率                       |
| `restrict`   | 用于指针，表明该指针是访问数据的唯一方式，帮助编译器优化 |

#### **C11 标准新增关键字 (7个)** ####

| 关键字           | 简要说明                                 |
| ---------------- | ---------------------------------------- |
| `_Alignas`       | 指定变量或结构体成员的内存对齐方式       |
| `_Alignof`       | 查询类型的对齐要求                       |
| `_Atomic`        | 声明原子类型，用于多线程编程             |
| `_Generic`       | 实现泛型选择，根据表达式类型选择不同代码 |
| `_Noreturn`      | 指示函数不会返回到调用者                 |
| `_Static_assert` | 在编译时进行断言检查                     |
| `_Thread_local`  | 声明线程局部存储变量                     |

#### 💡 关键字使用须知 ####

- **注意兼容性**：在编程时，请注意你使用的编译器支持哪个C语言标准。如果你在代码中使用了C99或C11新增的关键字，尤其是那些以下划线开头的关键字，需要确保编译环境支持相应的标准。
- **关键字非函数**：==**sizeof**是关键字而非函数。==
- **`main`和`include`非关键字**：==**main**函数是程序入口，**include**是预处理指令，它们都不是关键字。==







---

###答疑：



###2、putchar(c) function/macro always outputs character c to the _______________


A.screen						B.standard output


C.depends on the compiler	D.depends on the standard

- **✅ B. standard output (标准输出)**：这是最精确的答案。标准输出通常默认指向屏幕，但它可以被重定向到其他位置，如文件或打印机 。`putchar`的严格定义是向“标准输出流”写入字符 。
- **❌ A. screen (屏幕)**：这个说法虽然常见，但不够准确。它描述了默认情况下的行为，却忽略了标准输出可以被重定向这一重要特性。
- **❌ C/D. depends on the compiler/standard (依赖于编译器/标准)**：C语言标准明确定义了 `putchar`函数的行为，其输出目标是标准输出，这并不随编译器或标准的不同而改变 。



###3、`printf("%07d",1212);`的输出结果是：

| 格式组件 | 含义                                                    |
| :------- | :------------------------------------------------------ |
| `%`      | 格式控制符的开始 。                                     |
| `0`      | **标志位**：指定用 `0`进行前导填充，而不是默认的空格 。 |
| `7`      | **宽度**：指定整个数字字段的最小宽度为7个字符 。        |
| `d`      | **转换说明符**：表示以十进制有符号整数的格式输出 。     |

| 格式控制符 | 含义解析                                             | 示例 (整数 `42`为例)  | 输出结果                   |
| :--------- | :--------------------------------------------------- | :-------------------- | :------------------------- |
| **`%.7d`** | **精度控制**：输出至少7位整数，不足时在**左侧补0**。 | `printf("%.7d", 42);` | `0000042`                  |
| **`%7d`**  | **宽度控制**：输出至少7位，不足时在**左侧补空格**。  | `printf("%7d", 42);`  | `______42`(下划线代表空格) |
| **`%07d`** | **宽度+补零**：输出至少7位，不足时在**左侧补0**。    | `printf("%07d", 42);` | `0000042`                  |



### 5、scanf("%d\n",&x)的'\n'会显性对应缓冲区的换行符，从而丢弃它吗？ ###

​	你在 `scanf`的格式字符串中加入 `\n`的做法是**不正确**的。这会导致一个非常常见且反直觉的问题：程序会要求你输入超过预期的次数才能继续执行。

#### 问题根源：`scanf`中 `\n`的真实含义 ####

​	在 `scanf`函数的格式字符串中，`\n`并**不**代表“等待用户输入一个换行符”。它的真实含义是：**“匹配并跳过任意数量的空白字符（包括空格、制表符、换行符等），直到遇到一个非空白字符为止”**。这意味着，当你使用 `scanf("%d,%d\n", &a, &b);`时，会发生以下情况：

1. `%d,%d`成功读取了两个整数。
2. 随后遇到 `\n`，函数开始“等待并跳过”空白字符。
3. 你按下回车键产生的换行符会被这个 `\n`匹配并“吃掉”。
4. 但 `\n`的指令是“直到遇到非空白字符”，所以 `scanf`并不会就此结束，它会继续等待输入，**直到你输入一个非空白字符（比如随便一个字母或数字）后才会继续**。这就导致了你需要“多输入一次”的奇怪现象。



###6、`scanf("%[^\n]")`和`scanf("%s")`在处理换行符时有什么本质区别？

​	理解 `scanf("%[^\n]")`和 `scanf("%s")`在处理换行符上的区别，关键在于看清它们读取数据的“规则”有何不同。简单来说，一个像“贪婪”的读取器，另一个则像“谨慎”的读取器。

| 特性                   | `scanf("%[^\n]")`                                           | `scanf("%s")`                                                |
| :--------------------- | :---------------------------------------------------------- | :----------------------------------------------------------- |
| **工作原理**           | 读取**除了换行符(`\n`)** 以外的所有字符，直到遇见`\n`才停止 | 跳过**前导**空白符（包括空格、制表符、换行符），读取后续非空白字符，再遇到**任意**空白符（空格、制表符、换行符等）时停止 |
| **对换行符`\n`的处理** | **不读取**换行符，并将其**保留**在输入缓冲区中              | 作为**停止读取的标志**之一，如果它是前导空白符会被**跳过**，如果是结束标志则会被**留下** |
| **能否读取空格**       | **可以**。空格不被视为特殊字符，会正常读取                  | **不可以**。遇到空格即停止读取                               |
| **常见应用场景**       | 输入包含空格的完整句子或整行文字                            | 输入单个不包含空格的单词                                     |

💡 **深入理解与注意事项**

1. **缓冲区“残留”问题**使用 `%[^\n]`后，换行符 `\n`会留在输入缓冲区里。如果紧接着使用另一个 `%[^\n]`或 `%c`（用于读取单个字符）来读取输入，它会立刻遇到这个残留的 `\n`并直接返回，导致程序看似“跳过”了这次输入。解决方法是在下次读取前**清空缓冲区**，例如使用 `getchar()`吸收掉这个换行符，或者在格式字符串中加入 `%*c`来“吃掉”这个字符但不保存。
2. **`%s`的“自动跳过”机制**`%s`在开始读取有用数据前，会主动忽略（跳过）所有的前导空白符，包括换行符、空格等。这个特性使得它在读取一系列由空白分隔的单词时非常方便，因为你不需要担心前一个输入后缓冲区里残留的换行符会影响下一个 `%s`的读取。
3. **安全性考虑**无论是 `%[^\n]`还是 `%s`，如果不对读取的长度做限制，都有可能因为用户输入过长而导致**缓冲区溢出**，这是一个严重的安全风险。更安全的做法是**指定最大读取宽度**，例如有一个字符数组 `char str[100]`，你应该使用 `scanf("%99[^\n]", str)`或 `scanf("%99s", str)`，为字符串结束符 `\0`预留一个位置。



- 



---

## 代码实例：

### 1、下面的代码会输出什么？

```c
struct {
  int a; int *b;
} s[4], *p;
int i, n = 1;    
for(i = 0; i < 4; i++){
      s[i].a = n;
      s[i].b = &s[i].a;
      n = n + 2;
}
p = &s[0];
printf("%d\n", ++*p->b);
p++;
printf("%d,%d\n", (++p)->a, (p++)->a); 
```

​	问题核心在于C语言中函数参数的**求值顺序**以及**后缀自增 (`p++`)** 的副作用发生时机。

| 步骤 | 代码执行点                                  | `p`的指向（假设s[0]地址为A，s[1]为A+1，以此类推） | 关键操作解释                                                 |
| ---- | ------------------------------------------- | ------------------------------------------------- | ------------------------------------------------------------ |
| 1    | **第二个 `printf`：开始对参数从右向左求值** |                                                   | **求值顺序是核心**                                           |
| 2    | 先计算最右参数：`(p++)->a`                  | 仍指向 `s[1]`(A+1)                                | 1.  取当前 `p`(指向 `s[1]`) 的 `a`成员，得到 **3**。  2.  对 `p`进行后缀自增：`p++`这个操作产生一个**副作用**，即 `p`将指向下一个位置 (`s[2]`)，但**副作用的发生时机是在该表达式值被使用之后**。 |
| 3    | 计算左侧参数：`(++p)->a`                    | 当前 `p`已因步骤4的副作用指向 `s[2]`(A+2)         | 1.  对 `p`进行前缀自增：`++p`。此时 `p`从 `s[2]`移向 `s[3]`。  2.  取当前 `p`(指向 `s[3]`) 的 `a`成员，得到 **7**。 |
| 4    | **`printf`输出**                            | 最终 `p`指向 `s[3]`(A+3)                          | 输出顺序为左参数到右参数：**7, 3**                           |

💡 **核心原因与关键点**

1. **参数求值顺序**：C语言标准规定，函数参数的求值顺序是**未指定的**，编译器可以实现为从右向左或从左向右。==printf函数的参数求值顺序**并不是**我们通常认为的从左到右。恰恰相反，在许多编译器中，它们是从右向左被计算的。==正是这个“从右向左”的求值顺序导致了 `(p++)->a`先被计算。
2. **避免此类写法**：这种依赖于特定参数求值顺序和自增运算符副作用发生时机的代码，会产生**未定义行为**或至少是**实现定义行为**。这意味着在不同的编译器或不同的优化级别下，结果可能不同（例如，如果编译器选择从左向右求值参数，结果可能大相径庭）。写出清晰、不依赖求值顺序的代码是更好的选择。

#### 🔍 求值顺序的规则与不确定性 ####

​	理解这个问题的核心在于区分两点：

1. **参数求值顺序（Evaluation Order）**：指函数调用时，它的各个参数表达式（如 `(++p)->a`, `(p++)->a`）被计算的先后顺序。
2. **输出顺序（Output Order）**：指 `printf`函数按照格式字符串中 `%d`出现的顺序，将已计算好的值打印出来的顺序。

​	关键在于，**C语言标准并未规定函数参数的求值顺序**。编译器可以自由选择从左到右、从右到左，甚至其他顺序来进行求值。这意味着不同的编译器或不同的编译设置可能导致不同的求值顺序。在实践中，**许多主流编译器（如GCC、Clang）默认采用从右向左的顺序对函数参数进行求值**。



###2、下面的代码会输出什么？

```c
include <stdio.h>
int main()
{
printf("sanfoundry\rclass\n");
return 0;
}
```

1. **字符串结构**：`printf("sanfoundry\rclass\n");`包含三部分：`"sanfoundry"`：先输出这10个字符（光标在第10位后）。==`\r`（回车符）：**将光标移回行首**（位置0），但不换行。`"class"`：从行首开始覆盖原内容，替换前5个字符（`sanfo`→ `class`）。==`\n`（换行符）：最后将光标移到下一行。
2. **覆盖过程**：初始输出：`s a n f o u n d r y`（光标在 `y`后）。回车后覆盖：`c l a s s`覆盖 `s a n f o`，剩余 `u n d r y`未被覆盖。结果字符串变为：`c l a s s u n d r y`（即 `"classundry"`）。
3. **💡 关键知识点**
   - `\r`和 `\n`的区别：`\r`仅回车到行首（类似打字机“复位”），不换行；后续输出会**覆盖**当前行内容。`\n`是换行符，移动光标到下一行首。





