# C语言知识点 · 循环/分支控制篇

##答疑：

### 1、do-while和while循环的while后的分号分别可以省略吗？

​	下面是关于do-while和while循环在分号使用上的区别：

| 循环类型         | while后是否可省略分号    | 说明                                                         |
| :--------------- | :----------------------- | :----------------------------------------------------------- |
| **do-while循环** | **不可省略**             | `while(条件表达式)`**后面的分号是语法的一部分**，省略会导致编译错误。 |
| **while循环**    | **可以省略（通常不写）** | `while(条件表达式)`后面直接跟循环体（用`{}`括起或单条语句），**此处不需要分号**。若加分号会产生空循环体。 |



###2、循环体如包括有一个以上的语句，则必须用一对大括号{}括起来，组成复合语句。复合语句在语法上被认为是一条语句吗？大括号后面需要添加分号吗？

​	下面是关于do-while和while循环在分号使用上的区别：

| 循环类型         | while后是否可省略分号    | 说明                                                         |
| :--------------- | :----------------------- | :----------------------------------------------------------- |
| **do-while循环** | **不可省略**             | `while(条件表达式)`**后面的分号是语法的一部分**，省略会导致编译错误。 |
| **while循环**    | **可以省略（通常不写）** | `while(条件表达式)`后面直接跟循环体（用`{}`括起或单条语句），**此处不需要分号**。若加分号会产生空循环体。 |



### 3、break 语句只能用在循环体内和 switch 语句体内吗？

​	是的，`break`语句确实主要设计用于**循环体内**和 **`switch`语句体内**。下面这个表格能帮你快速掌握它的使用规则：

| 应用场景                                     | `break`语句的作用                                            | 备注与示例                                                   |
| :------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| **循环结构** (如 `for`, `while`, `do-while`) | **立即终止当前所在层的循环**，程序流程跳转到循环结构之后的语句继续执行。 | 通常与 `if`条件语句配合使用，在满足特定条件时提前结束循环。  |
| **`switch`选择结构**                         | ==**结束当前 `case`分支**，防止程序流程继续“穿透”执行后续的 `case`分支。== | 这是 `switch`语句的标准用法，以确保每个分支的独立性。        |
| **嵌套循环**                                 | **只能跳出其所在的最内层循环**，而不会影响外层循环的执行。   | 若需直接跳出多层嵌套循环，通常需要结合使用标签（某些语言支持）或设置标志变量。 |



###4、else 总是与它上面最近的且尚未配对的 if 配对？

​	是的，你说的完全正确。在C语言中，`else`语句遵循 **“就近匹配”原则**，它总是与同一代码块内、位于它上方、**最近的、尚未与其他else配对的`if`** 进行配对。==这个规则与代码的缩进格式无关，完全由语法结构决定。==



### 5、switch语句有哪些规则？

- `switch`的表达式必须是整型（==包括`char`，因为它是整型==）。
- `case`标签必须是整型==常量==表达式（如数字、字符常量），且不能重复。
- `case`标签后不能是变量或非常量表达式。
- C语言要求`case`值必须唯一，就像不能给同一个人起两个昵称一样～编译时会报错哦。
- `case`标签必须是==常量==！例如`case`标签`op == '+'`是一个表达式，涉及变量`op`，不是常量表达式！C语言要求`case`必须是编译时常量。



### 6、default分支的隐藏知识点有哪些？

- C语言允许`switch`语句中只有`default`，没有`case`。这就像是一个“万能备用计划”呢～（笑）

- `default`分支可以放在任意位置。如果它不在末尾且后面没有`break`，同样会发生穿透。通常建议将`default`放在最后以提高可读性

  。



###7、case穿透在什么情况下会或者不会发生？

| 情况                                  | 是否发生穿透                     | 代码示例                                                     | 结果说明                                                     |
| :------------------------------------ | :------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| **1. 无 `break`语句**                 | **会发生**                       | `switch (2) { case 2: printf("Two "); case 3: printf("Three"); }` | 输出：`Two Three`。匹配到`case 2`后，由于没有`break`，会继续执行`case 3`的语句。 |
| **2. 故意省略 `break`（多case合并）** | **会发生**                       | `switch ('B') { case 'A': case 'B': case 'C': printf("Pass"); break; }` | 输出：`Pass`。这是有意利用穿透让`'A'`, `'B'`, `'C'`三个case执行同一段代码。 |
| **3. 有 `break`语句**                 | **不会发生**                     | `switch (1) { case 1: printf("One"); break; case 2: printf("Two"); }` | 输出：`One`。`break`会立即终止整个`switch`语句，跳出`switch`结构。 |
| **4. 空 `case`块**                    | **不会发生**（实质是穿透的起点） | `switch (1) { case 1: // 此case为空，无语句 case 2: printf("Hello"); }` | 输出：`Hello`。匹配到空的`case 1`后，由于没有`break`，会自然穿透到`case 2`并执行其语句。 |
| **5. 执行到 `switch`末尾**            | **不会发生**（自然结束）         | `switch (3) { case 3: printf("End"); // 最后一条语句，无break }` | 输出：`End`。执行完最后一个语句块后，程序正常退出`switch`，不存在“穿透出去”的概念。 |

**穿透的本质**：`case`穿透是指当程序流进入某个`case`分支后，如果该分支**没有以`break`语句结束**，它将继续执行**后续所有`case`标签下的代码**，而不再进行条件匹配，直到遇到`break`或整个`switch`语句结束。这既是C语言语法的一部分，也是一个常见的错误来源。



###8、

---

## 代码实例：

###1、What will be the output of the following C code?
```c
#include <stdio.h>
int main()
{
    int a = 1, b = 1;
    switch (a)
    {
       case a*b:
          printf("yes ");
       case a-b:
          printf("no\n");
          break;
    }
}
```
**A.yes						B.no**

**C.Compile time error		D.yes no**

​	这段C代码在编译时会出现错误。正确答案是 **C. Compile time error**。

#### 错误原因分析 ####

​	导致编译错误的核心原因是 **`case`标签的使用不符合C语言的语法规定**。

- **`case`标签必须是常量表达式**：在C语言中，`switch`语句的 `case`标签后必须跟一个**整型常量表达式**。这意味着表达式的值必须在编译时就能确定，不能包含变量。
- **代码中的问题**：在你的代码中，第一个 `case`标签写的是 `case a*b:`，第二个是 `case a-b:`。这里虽然 `a`和 `b`都被初始化为1，使得 `a*b`和 `a-b`在运行时计算结果分别是1和0，但 `a`和 `b`本身是变量。因此，`a*b`和 `a-b`是**非常量表达式**，这违反了C语言的语法规则。

​	简单来讲，编译器在编译阶段无法确认 `a*b`和 `a-b`的具体值，因为变量是可变的。所以，它会直接报错。

#### 正确的写法 ####

​	如果你需要根据变量 `a`的值进行分支判断，`case`标签应该使用明确的整型常量。例如，如果希望当 `a`的值为1时执行某些操作，应写为 `case 1:`。

​	如果你想根据表达式（如 `a*b`）的结果来分支，则需要使用 `if-else`语句来代替 `switch`，因为 `if`语句的条件表达式可以是运行时计算出的值。



###2、What will be the output of the following C code? (Assuming that we have entered the value 1 in the standard input)

```c
#include <stdio.h>
void main()
{
    double ch;
    printf("enter a value between 1 to 2:");
    scanf("%lf", &ch);
    switch (ch)
    {
       case 1:
          printf("1");
          break;
       case 2:
          printf("2");
          break;
    }
}
```

**A.Compile time error		B.1**

**C.2						D.Varies**

​	正确的答案是 **A. Compile time error**。

#### 错误原因分析 ####

​	这段代码会导致编译错误，主要原因在于 `switch`语句的表达式类型不符合C语言的语法规定。

- **`switch`语句的限制**：在C语言中，`switch`关键字后面的表达式必须是一个**整型**（如 `int`, `char`）或**枚举类型**。它不能是 `double`这样的浮点类型。
- **类型不匹配**：在你的代码中，变量 `ch`被声明为 `double`类型，并直接用作 `switch (ch)`的表达式。这是不允许的，编译器会因此报错。

#### 深入理解 ####

- **`case`标签的要求**：与 `switch`表达式必须为整型相对应，`case`后面的常量表达式也必须是整型值。使用浮点数作为 `case`标签同样会引发编译错误。
- **正确的做法**：如果你需要根据一个浮点数的值进行分支选择，应该使用 `if-else if-else`语句结构来代替 `switch`。
