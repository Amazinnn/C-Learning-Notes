# C语言知识点 · 循环、分支篇

## 基础知识：

### 1、switch语句有哪些规则？

- `switch`的表达式必须是整型（==包括`char`，因为它是整型==）。
- `case`标签必须是整型==常量==表达式（如数字、字符常量），且不能重复。
- `case`标签后不能是变量或非常量表达式。
- C语言要求`case`值必须唯一，就像不能给同一个人起两个昵称一样～编译时会报错哦。
- `case`标签必须是==常量==！例如`case`标签`op == '+'`是一个表达式，涉及变量`op`，不是常量表达式！C语言要求`case`必须是编译时常量。



### 2、default分支的隐藏知识点有哪些？

- C语言允许`switch`语句中只有`default`，没有`case`。这就像是一个“万能备用计划”呢～（笑）

- `default`分支可以放在任意位置。如果它不在末尾且后面没有`break`，同样会发生穿透。通常建议将`default`放在最后以提高可读性。



###3、case穿透在什么情况下会或者不会发生？

| 情况                                  | 是否发生穿透                     | 代码示例                                                     | 结果说明                                                     |
| :------------------------------------ | :------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| **1. 无 `break`语句**                 | **会发生**                       | `switch (2) { case 2: printf("Two "); case 3: printf("Three"); }` | 输出：`Two Three`。匹配到`case 2`后，由于没有`break`，会继续执行`case 3`的语句。 |
| **2. 故意省略 `break`（多case合并）** | **会发生**                       | `switch ('B') { case 'A': case 'B': case 'C': printf("Pass"); break; }` | 输出：`Pass`。这是有意利用穿透让`'A'`, `'B'`, `'C'`三个case执行同一段代码。 |
| **3. 有 `break`语句**                 | **不会发生**                     | `switch (1) { case 1: printf("One"); break; case 2: printf("Two"); }` | 输出：`One`。`break`会立即终止整个`switch`语句，跳出`switch`结构。 |
| **4. 空 `case`块**                    | **不会发生**（实质是穿透的起点） | `switch (1) { case 1: // 此case为空，无语句 case 2: printf("Hello"); }` | 输出：`Hello`。匹配到空的`case 1`后，由于没有`break`，会自然穿透到`case 2`并执行其语句。 |
| **5. 执行到 `switch`末尾**            | **不会发生**（自然结束）         | `switch (3) { case 3: printf("End"); // 最后一条语句，无break }` | 输出：`End`。执行完最后一个语句块后，程序正常退出`switch`，不存在“穿透出去”的概念。 |

**穿透的本质**：`case`穿透是指当程序流进入某个`case`分支后，如果该分支**没有以`break`语句结束**，它将继续执行**后续所有`case`标签下的代码**，而不再进行条件匹配，直到遇到`break`或整个`switch`语句结束。这既是C语言语法的一部分，也是一个常见的错误来源。













---

##答疑：

### 1、do-while和while循环的while后的分号分别可以省略吗？

​	下面是关于do-while和while循环在分号使用上的区别：

| 循环类型         | while后是否可省略分号    | 说明                                                         |
| :--------------- | :----------------------- | :----------------------------------------------------------- |
| **do-while循环** | **不可省略**             | `while(条件表达式)`**后面的分号是语法的一部分**，省略会导致编译错误。 |
| **while循环**    | **可以省略（通常不写）** | `while(条件表达式)`后面直接跟循环体（用`{}`括起或单条语句），**此处不需要分号**。若加分号会产生空循环体。 |



###2、复合语句在语法上被认为是一条语句吗？大括号后面需要添加分号吗？

​	循环体如包括有一个以上的语句，则必须用一对大括号{}括起来，组成复合语句。下面是关于do-while和while循环在分号使用上的区别：

| 循环类型         | while后是否可省略分号    | 说明                                                         |
| :--------------- | :----------------------- | :----------------------------------------------------------- |
| **do-while循环** | **不可省略**             | `while(条件表达式)`**后面的分号是语法的一部分**，省略会导致编译错误。 |
| **while循环**    | **可以省略（通常不写）** | `while(条件表达式)`后面直接跟循环体（用`{}`括起或单条语句），**此处不需要分号**。若加分号会产生空循环体。 |



### 3、break 语句只能用在循环体内和 switch 语句体内吗？

​	是的，`break`语句确实主要设计用于**循环体内**和 **`switch`语句体内**。下面这个表格能帮你快速掌握它的使用规则：

| 应用场景                                     | `break`语句的作用                                            | 备注与示例                                                   |
| :------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| **循环结构** (如 `for`, `while`, `do-while`) | **立即终止当前所在层的循环**，程序流程跳转到循环结构之后的语句继续执行。 | 通常与 `if`条件语句配合使用，在满足特定条件时提前结束循环。  |
| **`switch`选择结构**                         | ==**结束当前 `case`分支**，防止程序流程继续“穿透”执行后续的 `case`分支。== | 这是 `switch`语句的标准用法，以确保每个分支的独立性。        |
| **嵌套循环**                                 | **只能跳出其所在的最内层循环**，而不会影响外层循环的执行。   | 若需直接跳出多层嵌套循环，通常需要结合使用标签（某些语言支持）或设置标志变量。 |



###4、else 总是与它上面最近的且尚未配对的 if 配对吗？

​	是的。在C语言中，`else`语句遵循 **“就近匹配”原则**，它总是与同一代码块内、位于它上方、**最近的、尚未与其他else配对的`if`** 进行配对。==这个规则与代码的缩进格式无关，完全由语法结构决定。==



### 哪个关键字可用于跳出递归？

​	答案是**`return`**而不是**`break`**。关键在于理解“递归”是一种**函数调用自身**的机制，而不是循环。要结束一次递归调用并返回到上一层，应使用 **`return`** 来结束当前函数执行并返回。`break`主要用于跳出**循环**（`for`, `while`）或 `switch`语句，在递归函数内部使用 `break`无法正确跳出整个递归调用栈，因此是错误的。



###case后面可以跟一个宏或const修饰的变量吗？

​	在C语言中，`case`后面能否使用宏或`const`修饰的变量，答案截然不同。简单来说：**宏可以，但`const`变量不行**。下表清晰地展示了两者的核心区别。

| 特性               | 宏 (使用 `#define`)                    | `const`修饰的变量           |
| ------------------ | -------------------------------------- | --------------------------- |
| **本质**           | 预处理器进行的**文本替换**，结果是常量 | **只读变量**                |
| **值确定时机**     | **编译预处理阶段**                     | **程序运行阶段**            |
| **能否用于`case`** | **可以**（若替换后为整型常量）         | **不可以**（C语言标准规定） |

**深入理解规则**

1. **`case`的硬性要求** 

   `case`标签后面必须是一个**整型常量表达式**。这意味着这个值必须在**编译时**就能被确定下来，不能有任何不确定性。这是`switch`语句能够高效运行（例如通过跳转表实现）的基础。

2. **为什么宏可以** 

   宏定义（`#define`）在**编译预处理阶段**就会被直接替换成对应的文本。当你写 `case CONSTANT:`时，编译器实际看到的是 `case 2:`（假设宏`CONSTANT`定义为2）。它是一个不折不扣的整型常量，完全符合语法要求。

3. **为什么C语言中的`const`变量不行** 

   在C语言中，使用`const`关键字修饰的变量，其准确描述是"只读变量"。它的核心属性是"运行时不可修改"，但它仍然是一个**变量**，需要在程序运行时分配存储空间。因此，它不满足`case`标签必须在编译期确定值的要求。这一点是C和C++的一个重要区别：在C++中，`const`修饰的变量在某些情况下可以被视为常量表达式。









---

## 代码实例：

###1、下面的代码会输出什么？
```c
#include <stdio.h>
int main()
{
    int a = 1, b = 1;
    switch (a)
    {
       case a*b:
          printf("yes ");
       case a-b:
          printf("no\n");
          break;
    }
}
```
**A.yes						B.no**

**C.Compile time error		D.yes no**

​	这段C代码在编译时会出现错误。正确答案是 **C. Compile time error**。

​	导致编译错误的核心原因是 **`case`标签的使用不符合C语言的语法规定**。

- **`case`标签必须是常量表达式**：在C语言中，`switch`语句的 `case`标签后必须跟一个**整型常量表达式**。这意味着表达式的值必须在编译时就能确定，不能包含变量。
- **代码中的问题**：在你的代码中，第一个 `case`标签写的是 `case a*b:`，第二个是 `case a-b:`。这里虽然 `a`和 `b`都被初始化为1，使得 `a*b`和 `a-b`在运行时计算结果分别是1和0，但 `a`和 `b`本身是变量。因此，`a*b`和 `a-b`是**非常量表达式**，这违反了C语言的语法规则。

​	简单来讲，编译器在编译阶段无法确认 `a*b`和 `a-b`的具体值，因为变量是可变的。所以，它会直接报错。

​	如果需要根据变量 `a`的值进行分支判断，`case`标签应该使用明确的整型常量。例如，如果希望当 `a`的值为1时执行某些操作，应写为 `case 1:`。如果想根据表达式（如 `a*b`）的结果来分支，则需要使用 `if-else`语句来代替 `switch`，因为 `if`语句的条件表达式可以是运行时计算出的值。



###2、下面的代码会输出什么？（假设我们已经输入1）

```c
#include <stdio.h>
void main()
{
    double ch;
    printf("enter a value between 1 to 2:");
    scanf("%lf", &ch);
    switch (ch)
    {
       case 1:
          printf("1");
          break;
       case 2:
          printf("2");
          break;
    }
}
```

**A.Compile time error		B.1**

**C.2						D.Varies**

​	正确的答案是 **A. Compile time error**。

#### 错误原因分析 ####

​	这段代码会导致编译错误，主要原因在于 `switch`语句的表达式类型不符合C语言的语法规定。

- **`switch`语句的限制**：在C语言中，`switch`关键字后面的表达式必须是一个**整型**（如 `int`, `char`）或**枚举类型**。它不能是 `double`这样的浮点类型。
- **类型不匹配**：在你的代码中，变量 `ch`被声明为 `double`类型，并直接用作 `switch (ch)`的表达式。这是不允许的，编译器会因此报错。

#### 深入理解 ####

- **`case`标签的要求**：与 `switch`表达式必须为整型相对应，`case`后面的常量表达式也必须是整型值。使用浮点数作为 `case`标签同样会引发编译错误。
- **正确的做法**：如果你需要根据一个浮点数的值进行分支选择，应该使用 `if-else if-else`语句结构来代替 `switch`。



###3、下面两段代码完全等价吗？（两个循环中省略的代码相同）

```C
    int i;
    for(i=0; i<100; i++){
        /**
         此处省略代码若干行
         **/
    }
```

```C
    int i=0;
    while(i<100){
        /**
         此处省略代码若干行
         **/
        i++;
    }
```

​	这两段代码在给出的情况下（省略的代码相同且不包含 `continue`语句）是等价的，它们都会循环100次（i从0到99）。但如果省略的代码中包含 `continue`语句，那么它们就可能产生差异。

| 特性                  | 代码1: `for`循环               | 代码2: `while`循环             |
| --------------------- | ------------------------------ | ------------------------------ |
| **更新语句位置**      | 在循环头部的 `i++`             | 在循环体末尾的 `i++`           |
| **执行 `continue`时** | **会执行** `i++`，然后判断条件 | **会跳过** `i++`，直接判断条件 |
| **潜在风险**          | 循环次数仍为100次              | 可能导致无限循环（`i`值停滞）  |

​	造成上述差异的根本原因在于两种循环的**语法结构**不同。

- **`for`循环**：其结构 `for(初始化; 条件; 更新)`将循环控制变量的更新（`i++`）作为一个独立的表达式放在了循环头部。这意味着，无论循环体内部是正常执行完毕还是通过 `continue`语句跳转，在进入下一次条件判断前，**`更新`表达式都会被执行**。
- **`while`循环**：它只关注循环条件。循环控制变量的更新（`i++`）是作为循环体内的一条**普通语句**存在的。如果 `continue`语句在 `i++`之前执行，就会直接跳转到循环开始的条件判断部分，从而**跳过本次循环的 `i++`**。这会导致变量 `i`的值不再增加，循环条件永远满足，从而陷入无限循环。
