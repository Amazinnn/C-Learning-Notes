# C语言学习 · 指针篇

[TOC]

## 基础知识：

###1、函数指针的基本用法

​	函数指针的使用主要包含三个步骤：**定义指针变量**、**让指针指向函数**、**通过指针调用函数**。

1. **定义函数指针变量**函数指针变量的定义语法看起来有点特别，需要你细心留意：`返回类型 (*指针变量名)(参数类型列表);`例如，要定义一个指向“返回`int`类型、并接受两个`int`类型参数”的函数的指针，可以这样写：`int (*p)(int, int); // 定义指向函数的指针变量p`这里的括号`(*p)`是必须的，它表明`p`首先是一个指针，然后指向一个函数。如果写成`int *p(int, int);`，编译器会认为`p`是一个返回`int*`类型（整型指针）的函数，这就完全不一样了。
2. **让指针指向函数**让指针指向一个函数非常简单，只需要将函数名赋给指针变量即可：`p = max; // 假设max是一个符合类型的函数，使p指向max函数`这里，函数名`max`就代表了该函数在内存中的起始地址（入口地址）。你也可以写成`p = &max;`，两种写法是等价的，但通常省略`&`的写法更常见。
3. **通过指针调用函数**通过函数指针调用它所指向的函数，也有两种等效的方式：`c = (*p)(a, b); // 方式一：使用解引用操作符 c = p(a, b);    // 方式二：直接使用指针变量名（更简洁的现代风格）`这两种方式都能成功调用`p`指向的函数，效果与直接写`c = max(a, b);`完全相同。



### 2、指针和数组有哪些异同？

​	理解指针和数组的异同确实是掌握C语言的关键。为了让你一目了然，我们先通过下面这个表格来梳理它们的核心区别，然后再解释一些重要的关联和细节。

| 特性             | 数组                                                         | 指针                                                         |
| :--------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| **本质**         | 一段**连续的内存块**，用于存储多个相同类型的数据             | 一个**变量**，其值是另一个变量的内存地址                     |
| **内存占用**     | 所有元素占用的内存总和（如 `int arr[5]`占用 20 字节）        | 固定大小（4字节或8字节，取决于系统位数）                     |
| **身份/可改性**  | 数组名是**常量**，代表一块固定内存的起始地址，不可被重新赋值 | 指针是**变量**，其存储的地址可以被改变，从而指向不同的内存单元 |
| **`sizeof`操作** | 返回整个数组所占的字节总数                                   | 返回指针变量本身所占的字节数（地址长度）                     |
| **赋值操作**     | 不能直接赋值（如 `arr1 = arr2`是错误的）                     | 可以相互赋值（如 `ptr1 = ptr2`是合法的）                     |
| **支持运算**     | 数组名不支持自增(++)、自减(--)等运算                         | 指针支持算术运算（如++, --, +, -），用于移动指向的位置       |
| **内存分配**     | 通常在编译时静态确定（如栈上分配）                           | 可以动态分配和释放（如使用 `malloc`和 `free`）               |

🔗 **重要的联系与共同点**

​	尽管有上述区别，指针和数组在C语言中关系非常密切，这也是它们容易混淆的原因：

1. **访问方式的相似性**：两者都支持使用下标运算符 `[]`和间接寻址运算符 `*`来访问元素。例如，`arr[i]`和 `*(ptr + i)`是等价的。
2. **数组名的“退化”**：在大多数表达式中，数组名会被编译器自动转换为指向其首元素的指针。例如，当我们将数组 `arr`传递给一个函数时，函数内部接收到的是一个指针，而不是整个数组的副本。这就是为什么在函数内部无法用 `sizeof(arr)`来获取数组实际长度的原因。
3. **作为函数参数**：当数组作为函数参数时，它完全等价于一个指针。`void func(int arr[])`和 `void func(int *arr)`是两种完全等价的写法。

⚠️ **常见误区与注意事项**

1. **函数参数退化**：这是最常见的陷阱。在函数内部，对数组参数使用 `sizeof`得到的是指针的大小，而不是原数组的大小。因此，通常需要额外传递一个参数来表示数组长度。
2. **`&arr`与 `arr`**：虽然它们的值（地址）相同，但类型不同。`arr`是首元素的地址（类型为 `int*`），而 `&arr`是整个数组的地址（类型为 `int(*)[5]`）。对后者进行指针运算（如+1）会跳过整个数组的长度。
3. **指针数组 vs 数组指针**：**指针数组**：本质是数组，数组里存放的是指针。例如 `int *ptr_arr[10]`。**数组指针**：本质是指针，指向一个数组。例如 `int (*arr_ptr)[10]`。



###3、有两个间接取值运算符是什么意思？

​	两个间接取值运算符（`**`）表示您正在使用一个**二级指针**。`**pp`的意思是：先通过 `*pp`取得它指向的那个一级指针（也就是 `p`），然后再通过一次解引用 `*(*pp)`来获取这个一级指针所指向的整数值（也就是数组中的元素）。

| 概念                | 对应代码示例 (接上表变量)      | 含义解释                                                     |
| :------------------ | :----------------------------- | :----------------------------------------------------------- |
| 二级指针 (`pp`)     | `int **pp = &p;`               | 存储一级指针 `p`的地址。                                     |
| 一级解引用 (`*pp`)  | `*pp`（等价于 `p`)             | 获取 `pp`所指向的指针变量（即 `p`）的内容，也就是变量 `a`的地址。 |
| 二级解引用 (`**pp`) | `**pp`（等价于 `*p`等价于 `a`) | 先通过 `*pp`找到 `p`，再通过 `*p`找到 `a`，从而访问或修改变量 `a`的值。 |



###4、指针之间可以进行加减和比较大小吗？

​	在C语言中，指针之间的运算是有特定规则的。简单来说，指针之间可以进行比较运算，也可以进行减法运算，但**不能进行加法运算**。

| 运算类型                           | 是否允许     | 核心规则                                           | 有意义的前提条件                                       |
| :--------------------------------- | :----------- | :------------------------------------------------- | :----------------------------------------------------- |
| **比较运算**(>, <, >=, <=, ==, !=) | ✅ **允许**   | 比较的是内存地址的高低。                           | 通常要求两个指针指向**同一个连续的内存块**（如数组）。 |
| **减法运算**                       | ✅ **允许**   | 结果是两个地址之间相隔的**元素个数**，而非字节数。 | 两个指针必须指向**同一个数组**。                       |
| **加法运算**                       | ❌ **不允许** | 两个指针相加没有语义意义，会导致编译错误。         | 无                                                     |

💡 **深入理解指针运算**

- **指针的减法**：其结果是 `ptrdiff_t`类型的整数，代表两个指针之间能存放多少个这种类型的元素。计算时会自动考虑数据类型的大小，例如，一个`int`通常占4字节，若两指针地址相差8字节，相减结果便是2个元素。
- **指针的比较**：最常见的应用是在遍历数组时进行边界检查。通过比较当前指针和数组末尾之后的位置，可以防止越界。但需注意，比较指向**不同数组**或**不相关对象**的指针，其结果是**未定义行为**。

⚠️ **重要注意事项**

1. **避免未定义行为**：确保指针比较和减法运算只在有明确意义的范围内进行，例如在同一个数组或同一块动态分配的内存内部。
2. **`void\*`指针的限制**：`void*`是通用指针，可以指向任何数据类型，但因为编译器不知道它指向的数据类型大小（“步长”），所以**不能**进行 `p+1`或 `p++`这样的算术运算。在进行比较前，通常需要先强制转换为具体的指针类型。



###5、一维、二维数组作为参数传递给函数时的若干写法。

​	在C语言中，将数组传递给函数是一个核心概念，其本质是**传递数组的首地址**，而非整个数组的拷贝，因此函数内对数组元素的修改会直接影响原数组。下面我们详细探讨一维和二维数组作为函数参数的写法。

#### 📝 一维数组作为函数参数 ####

​	一维数组作为参数时，形参主要有以下三种等效的声明方式：

1. **指针形式**：`void func(int *arr, int size)`这是==最本质的形式==。`arr`是一个指针，直接接收数组的首地址。在函数内部，既可以用指针算术 `*(arr + i)`访问元素，也可以用下标形式 `arr[i]`。

2. **未指定大小的数组**：`void func(int arr[], int size)`这是最常见的形式之一。虽然形参写成了数组样式，但编译器会将其视为指针。方括号 `[]`仅起示意作用，其中的数字可以被忽略。

3. **已指定大小的数组**：`void func(int arr[10], int size)`这种写法指定了数组大小，但请注意，这个数字（例如10）**通常会被编译器忽略**。它只是对程序员的一个提示，函数内部不应依赖这个值进行边界检查，实际的数组操作范围仍应由 `size`参数控制。

   **关键注意事项**：

4. **必须传递数组长度**：由于数组在函数内退化为指针，使用 `sizeof(arr)`得到的是指针的大小，而非数组的总大小。因此，必须额外传递一个参数 `size`来指明数组的实际长度。

5. **函数调用**：调用函数时，只需传入数组名（即首地址）和长度即可：`func(my_array, my_size);`。

#### 📊 二维数组作为函数参数 ####

​	二维数组在内存中也是按行连续排列的，但传递方式更为复杂，因为需要让函数知道每一行有多少元素（列数），才能正确计算元素的偏移地址。主要有以下两种标准写法：

1. **指定列数的二维数组**：`void func(int arr[][COL], int rows)`这是最直观和推荐的方法。**第二维（列数）必须明确指定**，且要与实参的列数一致。第一维的大小可以省略，由 `rows`参数指定。
2. **数组指针**：`void func(int (*arr)[COL], int rows)`这种写法与第一种完全等价。`arr`是一个指针，它指向一个长度为 `COL`的一维数组。在函数内部，可以使用 `arr[i][j]`的方式访问元素。
3. **二级指针**：二维数组的==最本质形式==。不过需要注意将行数与列数向函数一并传递。

**对于动态或列数不定的二维数组**，可以将其视为一维数组进行指针操作：

​	**单指针+手动计算偏移**：`void func(int *arr, int rows, int cols)`将二维数组的首地址 (`&array[0][0]`或 `(int*)array`) 作为一维指针传入。在函数内部，通过 `*(arr + i * cols + j)`来访问 `array[i][j]`。



###6、对数组形参为指针的理解。

​	当数组作为函数参数时，为了**避免拷贝整个数组带来的巨大开销**，C语言直接传递数组的**首地址**。因此，形参形式上写的虽然是数组（如 `int a[]`），但编译器会将其视为一个**指针变量**（如 `int *a`）来处理。

📌 **核心要点速览**

| 对比维度     | 普通变量形参 (如 `int a`)                    | 数组作为形参 (如 `int a[]`)                                  |
| :----------- | :------------------------------------------- | :----------------------------------------------------------- |
| **传递机制** | **值传递**：传递的是变量值的副本。           | **地址传递**：传递的是数组首元素的地址。                     |
| **操作影响** | 函数内修改形参，**不影响**实参。             | 通过地址直接操作原数组内存，函数内修改**直接影响**实参。     |
| **内存占用** | 占用变量类型本身的大小（如int通常为4字节）。 | 形参退化为指针，仅占用一个指针的大小（通常4或8字节）。       |
| **长度信息** | 不涉及。                                     | **丢失**。在函数内 `sizeof(a)`得到的是指针大小，而非数组长度，必须额外传递长度参数。 |

⚠️ **最重要的实践提醒**

​	在函数内部，**无法通过 `sizeof(a) / sizeof(a[0])`来获取数组长度**，因为此时的 `a`已是指针。数组的长度信息必须在调用函数时作为另一个参数显式传递进去。



###7、malloc，realloc与calloc函数的书写格式与实现原理是什么？

在C语言中，`malloc`, `calloc`, 和 `realloc`是进行动态内存管理的核心函数，它们都来自 `stdlib.h`头文件。

| 函数          | 标准调用格式                             | 核心功能                              | 内存初始化                                       | 主要应用场景                               |
| ------------- | ---------------------------------------- | ------------------------------------- | ------------------------------------------------ | ------------------------------------------ |
| **`malloc`**  | `void *malloc(size_t size);`             | 分配指定字节的连续内存。              | **不初始化**，内容随机。                         | 分配任意类型或结构的内存，需手动初始化时。 |
| **`calloc`**  | `void *calloc(size_t num, size_t size);` | 分配 `num`个长度为 `size`的连续内存。 | **自动初始化为零**。                             | 为数组分配内存，并希望初始状态全为零时。   |
| **`realloc`** | `void *realloc(void *ptr, size_t size);` | 调整已分配内存块的大小。              | 新增部分**不初始化**；缩小则截断，数据可能丢失。 | 需要扩展或缩小之前动态分配的内存空间时。   |

💡 **实现原理浅析**

​	这些函数管理的内存位于“堆区”。它们通过维护一个“空闲内存块链表”来工作。申请内存时，分配器会遍历这个链表，寻找第一个足够大的空闲块。为了满足请求，它可能会将一个大的空闲块分割，一部分分配给你，剩余部分放回链表。释放内存（`free`）时，该内存块会被链接回空闲链表，并可能与相邻的空闲块合并，以减少碎片。

​	`realloc`的行为则更灵活一些：如果原内存块后方有足够的连续空间，它会直接扩展原内存块。如果空间不足，它会寻找一块足够大的新空间，将原有数据复制过去，并释放旧内存。







---

##答疑：

### 1、正确的Swap函数在做什么？ ###

你所说的那个正确的 `swap`函数，典型写法是这样的：

```
void swap(int *p1, int *p2) {
    int temp = *p1; // 获取p1指向的值
    *p1 = *p2;     // 将p2指向的值赋给p1指向的内存单元
    *p2 = temp;    // 将暂存的值赋给p2指向的内存单元
}
```

这个函数的工作过程是这样的：

1. **传递的是地址副本**：当你调用 `swap(&a, &b)`时，函数形参 `p1`和 `p2`接收到的是 `a`和 `b`的地址的**副本**。
2. **操作的是地址指向的值**：函数内部通过 `*`（解引用）操作符，直接访问 `p1`和 `p2`所指向的内存单元（也就是变量 `a`和 `b`所在的地方），并交换这两个内存单元里的**数据**。
3. **指针的指向从未改变**：在整个过程中，`p1`始终指向变量 `a`的地址，`p2`始终指向变量 `b`的地址。改变的是它们“家里”的“布置”（变量的值），而不是它们的“家门牌号”（指针的指向）。

​	所以，关键在于区分两个概念：

- **改变指针的指向**：即让指针变量存储另一个地址。在函数调用中，单纯改变形参指针的指向是无效的。
- **改变指针所指向的值**：即通过解引用操作，修改指针所指向的内存地址中存储的数据。这才是正确 `swap`函数的原理。

​	简单来说就是：**正确的swap函数交换的是“值”，而不是“地址”**。指针就像一个忠诚的向导，自始至终指向同一个地方，但函数通过这个向导把那个地方存放的宝物成功调包了！==PS：因此，使用指针变量，能将多个运算结果返回主调函数！==











### 6、不同类型的指针变量是可以直接相互赋值的吗？

​	在C/C++中，不同类型的指针变量不能直接相互赋值，编译器通常会报错。

​	`void*`是一种特殊的指针类型，它可以存放任何类型对象的地址，被称为“无类型指针”。你可以将任何指针直接赋值给`void*`指针，反之则**必须**进行强制类型转换。



### 8、若有定义 double *p;，使p指向一个双精度型的动态存储单元的语句为（	）。  

```c
A. p = malloc(sizeof(double));
B. p = (double *)malloc(sizeof(*p));
C. p = malloc(8);
D. p = (double *)malloc(sizeof(double));
```

| 选项 | 代码                                    | 正确性 | 关键分析                                                     |
| :--- | :-------------------------------------- | :----- | :----------------------------------------------------------- |
| A    | `p = malloc(sizeof(double));`           | ❌      | 缺少对`malloc`返回值的强制类型转换（`void*`到 `double*`）。在C++中会报错，虽然C语言允许隐式转换，但显式转换是更良好的编程习惯。 |
| B    | `p = (double *)malloc(sizeof(*p));`     | ✅      | **正确**。`sizeof(*p)`等价于 `sizeof(double)`，因为`p`是`double*`类型，解引用`*p`就是`double`类型。此写法灵活且不易出错。 |
| C    | `p = malloc(8);`                        | ❌      | 直接使用魔数`8`而非`sizeof`操作符。不同平台下`double`类型所占字节数可能不同，此写法不利于移植，且同样缺少类型转换。 |
| D    | `p = (double *)malloc(sizeof(double));` | ✅      | **正确**。标准写法，既进行了强制类型转换，又使用`sizeof`计算了准确的数据类型大小。 |





### 11、指针所占内存的大小由其指向的数据类型的大小决定吗？

​	**指针本身是一个变量，它存储的是内存地址，而不是实际的数据。**指针在内存中占用的空间大小取决于系统的架构，而不是它指向的数据类型的大小。

​	在32位系统中，指针通常占用4字节。在64位系统中，指针通常占用8字节。这意味着，无论指针指向的是int、double还是其他数据类型，指针本身的大小是固定的，由系统的地址总线宽度决定。因此，题目的陈述是错误的。



###13、可以这样写吗：`p=(int *)realloc(p,n*sizeof(int)); `

​	直接使用 `p = (int *)realloc(p, n * sizeof(int));`这种写法是**不安全**的。虽然语法上没有错误，但在实际编程中，这种做法存在一个明显的风险，可能会导致内存泄漏。

| 特性         | 不安全写法 (`p = realloc(p, ...)`)          | 推荐的安全做法 (使用临时指针)                                |
| :----------- | :------------------------------------------ | :----------------------------------------------------------- |
| **核心问题** | 内存泄漏风险                                | 保持原内存块安全                                             |
| **情景**     | 当`realloc`分配失败返回`NULL`时             | 先检查临时指针，成功后再赋值                                 |
| **后果**     | 原指针`p`丢失，原内存块无法被访问也无法释放 | 原指针`p`始终有效，可正常释放或进行其他处理                  |
| **代码示例** | `p = (int *)realloc(p, n * sizeof(int));`   | `int *temp = (int *)realloc(p, n * sizeof(int));` `if (temp != NULL) { p = temp; }` |

💡 **理解realloc的行为**

​	要理解为什么上面的写法不安全，关键是要知道`realloc`函数在无法满足扩大内存的请求时可能会返回`NULL`，但此时**原来`p`指向的那块内存依然存在**，需要你之后去释放。

​	如果你直接 `p = realloc(p, ...);`并且`realloc`失败返回了`NULL`，那么这个`NULL`值就覆盖了`p`原先的值。结果是，你不仅没有获得新的更大内存，还**丢失了**指向原来那块内存的“地址”，导致原来那块内存无法被访问也无法被释放，这就造成了“内存泄漏”。

🛠️ **正确的使用步骤**

安全的使用方法通常包含以下几步：

1. **使用临时指针**：用一个临时指针（比如`temp`）来接收`realloc`的返回值。
2. **检查是否成功**：判断临时指针是否为`NULL`。
3. **赋值**：如果临时指针非`NULL`（代表分配成功），再将这个新指针赋值给原指针`p`。
4. **处理失败**：如果临时指针为`NULL`，说明分配失败。你需要决定如何处理，比如报错并安全地使用原来的内存块，或者进行其他清理工作。

```c
#include <stdlib.h>

int main() {
    // 假设p已经指向一块动态分配的内存
    int *p = (int *)malloc(10 * sizeof(int));
    if (p == NULL) {
        // 处理初始分配失败
        return -1;
    }

    // 需要调整内存大小
    int n = 20;
    int *temp = (int *)realloc(p, n * sizeof(int)); // 使用临时指针

    if (temp != NULL) {
        // 重新分配成功，将新地址赋给p
        p = temp;
    } else {
        // 重新分配失败！但原来的内存块（p指向的）仍然存在
        // 可以进行错误处理，例如输出信息，并保证p指向的内存仍可使用/释放
        // 这里选择释放原内存后退出
        free(p);
        p = NULL;
        return -1;
    }

    // ... 使用扩大后的内存

    free(p); // 最后记得释放内存
    p = NULL;
    return 0;
}
```

📝 **补充注意事项**

- **指针可能移动**：`realloc`可能会在内存中**找一块新的足够大的区域，把旧数据复制过去，然后释放旧内存块。**所以**成功调用`realloc`后，原来指针`p`就不应再直接使用**，而应该使用返回的新指针（可能和原指针相同，也可能是新地址）。这也是为什么使用临时指针能避免混淆。
- **新内存未初始化**：如果`realloc`扩大了内存，新增加的那部分内存空间的内容是**未初始化**的，可能包含任意值。
- **缩小内存**：当使用`realloc`缩小内存块时，超出新尺寸的数据可能会丢失。



### pnew=malloc(sizeof(node)) ;这条语句是正确的吗？

​	给出的语句 `pnew = malloc(sizeof(node));`在**语法上是正确的**，但按照**良好的编程实践，它存在一个可以改进的地方**。

- **正确之处**：`malloc(sizeof(node))`能正确计算 `node`结构所需的内存大小并进行分配。在C语言中，`void*`指针可以自动转换为任何其他指针类型，所以直接赋值给 `pnew`（假设 `pnew`是 `node*`类型）不会报错。
- **可改进之处**：显式地加上类型转换会更清晰，即写成 `pnew = (node *)malloc(sizeof(node));`。虽然在现代C编译器中不是必须的，但这是一种更严谨的风格，尤其是在C++代码中（使用`new`是另一种情况）或为了代码的清晰性。



### 以下说法是正确的吗？

> 语句 int *p[5]; 定义了一个指针数组p，用于**指向**一个有5个元素的数组。  

​	这个说法是**错误**的。

- `int *p[5];`定义的是一个**指针数组**。核心是数组（`p[5]`），这个数组里有5个元素，每个元素都是一个指向整型数据（`int`）的指针。
- 描述中“用于指向一个有5个元素的数组”所定义的是**数组指针**，其正确写法应为 `int (*p)[5];`。核心是指针（`*p`），该指针专门指向一个包含5个整型元素的一维数组。



### 以下说法是正确的吗？

> 执行语句`int *p = 1000;`后，指针变量`p`指向地址为`1000`的变量。  

​	这个说法是**错误**的。

- **类型不匹配**：`1000`是一个整型常量，而 `int *p`需要的是一个地址。在C语言中，不能直接将整数值赋给指针变量，这会导致类型不匹配。编译器通常会给出类似 "initialization of ‘int *’ from ‘int’ makes pointer from integer without a cast" 的警告。
- **地址有效性**：即使通过强制类型转换（如 `int *p = (int *)1000;`）让代码编译通过，语句也只是让指针 `p`存储了地址值 `1000`。这**并不代表**内存中地址1000处存在一个有效的、可安全访问的 `int`类型变量。在大多数操作系统（如Windows、Linux）中，随意访问此类绝对地址很可能触发段错误（Segmentation Fault）导致程序崩溃，因为该内存区域通常受保护或不可被用户程序直接访问。





###若有定义`int(*p)();`标识符p可以___________________。

**A.表示函数的返回值**

**B.指向函数的入口地址**

**C.表示函数的返回类型**

**D.表示函数名**

​	正确答案是 **B. 指向函数的入口地址**。`int(*p)();`定义了一个函数指针 `p`，它用于存储函数的入口地址，从而可以指向一个返回 `int`类型且参数列表为空的函数。其他选项错误：

- A 和 C 混淆了指针与返回值、返回类型的关系；
- D 错误，`p`是指针变量，而非函数名本身。



###动态内存分配程序执行速度比静态内存分配快吗？

​	**在绝大多数情况下，静态内存分配的程序执行速度更快**。

​	**静态分配为何快**：静态内存分配在**程序编译或加载时**就已完成。程序运行时，内存早已准备就绪，直接使用即可，没有额外的运行时开销。例如，全局变量和静态变量位于静态数据区，局部变量在栈上分配，函数调用结束栈帧弹出时，这些内存也自动释放。

​	**动态分配为何慢**：动态内存分配发生在**程序运行时**。每次分配（如`malloc`、`new`）和释放（`free`、`delete`）都可能涉及**系统调用**，需要运行**内存管理算法**（如首次适应、最佳适应算法）在堆中寻找合适空间，并维护**堆数据结构**。这些操作都有不可忽视的时间开销。频繁的动态分配释放还易导致**内存碎片化**，使得后续分配可能需花费更多时间寻找可用空间，甚至触发垃圾回收（GC）整理内存，导致程序暂停。

---

## 代码实例：

###1、下面的程序只是修改p指针，为何修改line数组？

```c
/*压缩字符串中的相邻若干个重复字母*/
#include <stdio.h>
#define MAXLINE 80
void zip(char *p);
int main(void)
{
	char line[MAXLINE];
	printf("Input the string:");
	gets(line);
	zip(line);
	puts(line);
	return 0;
}
void zip(char *p)
{
	char *q=p;
	int n;
	while (*p!='\0'){
		n=1;
		while (*p==*(p+n)){
			n++;
		}
		if (n>=10){
			*q++=(n/10)+'0';
			*q++=(n%10)+'0';
		}
		else if (n>=2){
			*q++=n+'0';
		}
		*q++=*(p+n-1);
		p=p+n;
	}
	*q='\0';
}
```

​	你提出的这个问题非常关键，它触及C语言指针传参的核心概念——**“传递地址，共享内存”**。这个程序之所以能修改`line`数组，正是因为`zip`函数中的指针`q`和`p`从一开始就指向`main`函数中`line`数组的同一块内存地址。

✨ 核心原理：**指针与内存共享**

​	程序的奥秘就在于 `main`函数中的 `line`数组和 `zip`函数中的 `p`、`q`指针之间的关系：

- 当你在 `main`函数中调用 `zip(line)`时，你传递的是数组 `line`的**首地址**。这意味着函数内部的形参指针 `p`接收到了 `line[0]`的内存地址 。
- 紧接着，在 `zip`函数内，语句 `char *q = p;`让指针 `q`也指向了完全相同的起始位置。
- 因此，后续所有通过 `*q++ = ...`进行的操作，都不是在操作某个“副本”，而是**直接对 `line`数组原始内存空间进行覆盖写入**。这就是所谓的“双向传递”或“地址传递”，函数内部对指针所指内容的修改会直接反映到调用者的原始数据上 。



###2、下面程序段的运行结果是：___________________ 。

```c
char s[20]= "abcd" ; 
char *sp = s ;
puts(strcat(sp+1, "ABCD"+1)) ;
```

​	`strcat(sp+1, "ABCD"+1)`是代码的关键。

- **第一个参数 `sp+1`**：`sp`指向 `s[0]`，所以 `sp+1`指向 `s[1]`（字符 `'b'`）。从 `s[1]`开始的字符串是 `"bcd"`（因为其后有 `s[2]='c'`, `s[3]='d'`, `s[4]='\0'`）。
- **第二个参数 `"ABCD"+1`**：`"ABCD"`是字符串常量，在内存中为 `'A'`, `'B'`, `'C'`, `'D'`, `'\0'`。`"ABCD"+1`是指针运算，指向该字符串的第二个字符 `'B'`，因此实际代表字符串 `"BCD"`（从 `'B'`开始到结束符）。



###3、以下程序的输出是：

```c
int *p=0;
p+=6;
printf("%d\n",p);
```

**A.0			B.6**

**C.24			D.随机值**

​	题目 `int *p=0; p+=6; printf("%d\n",p);`的输出结果是 **24**（在常见32/64位系统，`int`为4字节时）。这道题巧妙地**揭示了指针作为“地址数值”和“类型化内存访问标签”的双重性**。虽然运算得到了24，但这属于对未定义行为的特定环境实现，在实际编程中应严格遵循规范。

#### 1. `p = 0`或 `p = NULL`的含义 ####

- **语义**：明确地将指针 `p`初始化为**空指针**，表示它“不指向任何有效的内存地址”。
- **本质**：在绝大多数系统实现中，`NULL`被定义为地址值 `0`。这是一个==被操作系统保护的、禁止用户程序进行读写操作的“禁区地址”==。
- **关键**：所有被赋值为 `0`或 `NULL`的指针，其存储的地址值在数值上是相等的，都指向**同一个无效的地址**。这正是“空指针”的标准和安全的表示方式，它不是一个指向有效数据的悬空指针，而是一个明确的、可检测的“无效”标志。

#### 2. 对空指针进行算术运算（`p+=6`）会发生什么？ ####

- **从语言标准看**：**这是“未定义行为”**。==C标准不保证其结果，编译器理论上可以做任何事==。
- **从实际实现看**：编译器通常将 `p += 6`解释为“从当前地址（0）向高地址移动 `6 * sizeof(int)`个字节”。 计算公式：`新地址 = 0 + 6 * sizeof(int)` 若 `sizeof(int) = 4`，则新地址值为 `24`。
- **重要区别**：指针运算的**单位是指针所指类型的大小**，而不是字节。`p+=6`是向后移动6个`int`的位置，而不是6个字节。

#### 3. 用 `%d`打印指针（`printf(“%d\n”, p)`）会发生什么？ ####

- **这是错误的，属于“未定义行为”**。标准规定应用 `%p`格式符来打印指针地址。
- **在实际环境中**：`%d`会将指针变量中存储的**地址值**（经过计算后的24），当作一个普通的32位有符号整数来解释和打印。这就是为什么输出是 `24`。
- **正确做法**：应使用 `printf(“%p\n”, (void*)p);`来安全、可移植地输出地址（此时输出将是 `0x18`或类似形式）。

```c
初始： p = 0x00000000
运算： p += 6; // 移动 6 个 int
计算： 新地址 = 0 + 6 * sizeof(int)
             = 0 + 6 * 4
             = 24 (十进制)
打印： printf("%d\n", p); // 将地址值24当作整数打印
输出： 24
```

⚠️ **关键总结与安全准则**

1. **明确“空指针”的意义**：`p=0`是设置一个明确的无效标志，便于检查（`if(p==NULL)`），不是获得一个可用的“零地址内存”。
2. **理解指针运算的本质**：运算单位是“类型大小”，不是字节。`(char*)p + 1`和 `(int*)p + 1`的增量不同。
3. **避免未定义行为**： 不要用 `%d`打印指针，用 `%p`。 不要对空指针进行解引用（`*p`）操作，这必然导致程序崩溃（段错误）。 对空指针进行算术运算的结果虽然可预测，但依赖它是不可移植、不安全的，应避免。
4. **良好的编程习惯**： 指针声明后立即初始化为 `NULL`。 在使用指针前（尤其是解引用前）检查是否为 `NULL`。 释放内存后，立即将指针置为 `NULL`，防止成为“野指针”。



### 4、运行下面两段代码，分别输出：

```c
char a[3][3]={"ad","ce","fb"},*s=(char *)a;
printf("%c",*++s-2);
```

- **输出结果**：`b`
- **简要分析**： 数组 `a`在内存中的布局为：`'a','d','\0','c','e','\0','f','b','\0'`（每行3字符，字符串末尾自动补`\0`）。 `s = (char *)a`将二维数组强制转换为 `char*`指针，初始指向 `a[0][0]`（地址对应字符 `'a'`）。 `*++s`先执行 `++s`，使 `s`指向 `a[0][1]`（字符 `'d'`），再解引用得到 `'d'`。 `'d' - 2`计算 ASCII 码：`100 - 2 = 98`，对应字符 `'b'`。

```c
float a[3][3];
printf("%d",(int)(a+1)-(int)&a[0][1]);
```

- **输出结果**：`8`（假设 `float`占4字节）
- **简要分析**： `a`是二维数组名，类型为 `float(*)[3]`（行指针）。`a+1`跳过一行（3个 `float`），地址增加 `3 * sizeof(float) = 12`字节。 `&a[0][1]`是首行第二个元素的地址，相对数组起始地址偏移 `1 * sizeof(float) = 4`字节。 差值：`(地址(a+1) - 地址(&a[0][1])) = (基址 + 12) - (基址 + 4) = 8`。

#### 指针强制类型转换的影响 ####

​	当对指针进行强制类型转换（如同数据类型不同级指针转换，或转为整型）时，关键变化如下：

| 转换类型                                                  | 效果说明                                                     | 注意事项                                                     |
| --------------------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **同数据类型的不同级指针转换**（如 `int[3][3]`转 `int*`） | 改变指针的**类型信息**，影响指针运算的步长。==原地址值不变，但解引用或加减运算时按新类型计算偏移。== | 例如：`float (*p)[3]`（行指针）转 `float*`（元素指针）后，`p+1`的偏移从一行（12字节）变为一个元素（4字节）。 |
| **指针与整型互转**（如 `(int)ptr`）                       | 将地址值转换为整数，可用于数值计算（如==地址差值==）。但整型可能无法完整存储地址（如32位`int`对64位指针），导致截断。 | 转换后失去指针语义，不能直接解引用。需确保整型宽度足够（如用 `uintptr_t`）。 |

**核心原则**：

​	强制类型转换**不改变指针持有的地址值**，但修改了编译器解释该地址的方式：

- **类型决定运算**：转换后，==指针加减的步长由新类型的大小决定==。
- **解引用行为**：解引用时==按新类型读写内存==（如 `char*`转 `int*`后读4字节而非1字节）。
- **风险**：错误转换可能引发越界访问（如二维数组转 `char**`后，`p[i][j]`的寻址逻辑错误）。

> 以上分析基于常见32位环境（`int`和指针均占4字节）。若环境不同（如64位系统），第二段代码的结果可能变化（需检查 `sizeof(float)`和指针大小）。



### 5、以下程序的输出是：

```c
char p[3][4]={"ABC","DEF","GHI"};
char *q[3],**pp;
pp=q+2;
q[0]=p[1];q[1]=p[2];q[2]=p[0];
putchar(pp[-1][-2]+3);
```

**程序输出结果**

该程序的输出是字符 **`I`**。

**程序逐步分析**

1.  `pp`指向 `q[2]`，因此： `pp[-1]`等价于 `*(pp - 1)`，即从 `pp`向前移动一个 `char*`单位，指向 `q[1]`的地址。解引用后得到 `q[1]`的值，即 `p[2]`的首地址（指向 `'G'`）。==注意：`pp`在指针数组`*q[3]`上操作，而非`p[3][4]`，这由`pp=q+2`赋值决定。==
2.  `pp[-1][-2]`等价于 `*(q[1] - 2)`。由于 `q[1]`指向 `p[2][0]`（地址偏移 8），向前移动 2 个 `char`单位后，指向地址偏移 6 的位置，即 `p[1][2]`，对应字符 `'F'`。 ==注意：此时`*pp`对应的指针指向`p[3][4]`，故在`p[3][4]`上操作。==
3. 因此，`pp[-1][-2]`是字符 `'F'`，其 ASCII 码为 70。`'F' + 3`得到 ASCII 码 73，对应字符 `'I'`。 `putchar`输出字符 `'I'`。

| 关键点                 | 说明                                                         | 程序中的体现                                                 |
| ---------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **二维数组的内存布局** | 二维数组在内存中按行优先连续存储，每行末尾有隐式终止符 `\0`。 | 数组 `p`的连续存储使得通过指针算术跨行访问成为可能（如从 `p[2]`向前访问到 `p[1]`）。 |
| **指针数组与二级指针** | 指针数组（如 `q`）存储地址而非数据；二级指针（如 `pp`）指向指针的地址，支持多级间接访问。 | `pp = q + 2`使 `pp`指向 `q[2]`，并通过 `pp[-1]`访问 `q[1]`。 |
| **指针算术与负索引**   | 指针加减运算以类型大小为步长（如 `char*`步长为1）。负索引（如 `pp[-1]`）是合法的，等价于 `*(pp - 1)`，但需确保不越界。 | `pp[-1][-2]`通过两次算术：先调整指针级别，再调整字符偏移。   |
| **类型决定指针运算**   | 指针的类型决定了运算的步长和解引用方式（如 `char**`与 `char*`的差异）。 | `pp`是 `char**`类型，`pp - 1`移动一个指针大小单位；而 `q[1]`是 `char*`类型，`q[1] - 2`移动 2 字节。 |
| **字符编码与运算**     | 字符在运算时使用 ASCII 码值，`putchar`将整型值转换为字符输出。 | `'F' + 3`计算 ASCII 码 73，对应 `'I'`。                      |

⚠️ **注意事项**

- **内存安全性**：此程序使用负索引（如 `pp[-1][-2]`）访问内存，虽在数组边界内是有效的，但实际编程中需谨慎避免越界。
- **指针类型的精确性**：二级指针和指针数组的配合需要严格匹配类型，否则可能导致未定义行为。

此程序集中体现了C语言指针操作的灵活性和底层内存管理细节，理解这些概念对深入掌握指针至关重要。
