# C语言知识点 · 函数篇

---
##答疑：


####1、函数声明和调用、定义时，可以不声明形参的变量名，但不能不声明类型？

| 场景         | 形参类型     | 形参变量名   | 核心要点                                                     |
| :----------- | :----------- | :----------- | :----------------------------------------------------------- |
| **函数声明** | 必须声明     | **可以省略** | 告知编译器函数的存在及其接口（返回值类型、函数名、形参类型、个数和顺序）。 |
| **函数调用** | **不能声明** | 必须提供实参 | 执行函数功能，需提供与形参类型匹配的实际参数值。             |
| **函数定义** | 必须声明     | 必须声明     | 实现函数功能，形参作为函数体内的局部变量。                   |



#### 2、C语言函数返回类型的默认定义类型是void吗？函数的实参与形参可以是常量，变量或表达式吗？

| 项目                 | 规则说明                                                     | 示例或备注                                                   |
| :------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| **函数默认返回类型** | 未明确指定时，默认为 **int**                                 | `fun() { return 5; }`默认返回 `int`类型。`void`==必须显式声明==。 |
| **显式声明返回类型** | 应始终显式声明返回类型（如 `int`, `void`, `double`等）       | `int fun() { ... }`, `void process() { ... }`                |
| **实参形式**         | 可以是**常量**、**变量**或**表达式**，但==必须有确定的值==。 | `func(10)`, `func(a)`, `func(a + b)`                         |
| **形参形式**         | 必须在函数定义中明确指定**类型**，形参只能是**变量**。       | `void func(int num, char ch)`                                |
| **参数传递方式**     | 默认采用**值传递**。函数内对形参的修改不影响实参。           | 若需修改实参，可传递指针（地址）。                           |



#### 3、按照C语言的规定，实参和形参的命名不得重复吗？

| 项目         | 说明                                                         |
| :----------- | :----------------------------------------------------------- |
| **语法规定** | **允许**实参与形参同名，也允许不同作用域的变量同名。         |
| **根本原因** | 实参和形参处于**不同的作用域**。形参的作用域仅限于其所在函数的函数体内部。 |
| **底层机制** | C语言默认采用**值传递**，函数调用时只是将实参的值拷贝给形参，二者是独立的存储单元。 |



#### 4、按照C语言的规定，在参数传递过程中，既可以将实参的值传递给形参，也可以将形参的值传递给实参，这种参数传递是双向的。  这是正确的吗？

​	这种说法是不准确的。根据C语言的规定，参数传递在本质上是**单向的“值传递”**，数据只能从实参传递给形参，而不能反过来由形参传回给实参。

​	为了让你更清晰地理解，下面这个表格总结了两种不同情况下的具体表现：

| 传递方式                 | 传递内容       | 能否改变实参的值           | 本质                                   |
| :----------------------- | :------------- | :------------------------- | :------------------------------------- |
| **普通变量（值传递）**   | 变量值的副本   | ❌ 不能                     | 单向传递                               |
| **指针变量（地址传递）** | 变量地址的副本 | ✅ 可以（通过地址间接修改） | 本质仍是单向的值传递（传递的是地址值） |



#### 5、函数递归调用自身时，每次调用都会得到一个与以前的变量集合不同的新的变量集合？

​	是的，你的理解完全正确。在C语言中，函数每次递归调用自身时，都会在内存中创建一套**全新的、独立的局部变量和参数**。这些变量集合互不干扰，这是递归能够正常工作的关键。

​	我们可以通过一个表格来对比递归调用和普通调用的变量状态：

| 调用类型         | 变量存储方式                           | 变量生命周期                       | 内存管理                   |
| :--------------- | :------------------------------------- | :--------------------------------- | :------------------------- |
| **递归调用**     | 每次调用都在**栈**上创建独立的变量副本 | 从本次调用开始到本次调用返回时结束 | 由系统自动在栈上分配和释放 |
| **普通函数调用** | 同样在栈上创建独立的变量集             | 从函数调用开始到函数返回时结束     | 由系统自动管理             |

#### 🧠 背后的机制：调用栈与栈帧 ####

​	递归调用能实现变量隔离，全靠**调用栈（Call Stack）** 和**栈帧（Stack Frame）** 机制。

- **调用栈**：你可以把它想象成一叠盘子。每次调用一个函数（包括递归调用），就相当于在最上面放一个新的盘子（即创建一个新的栈帧）。函数返回时，就把最上面的盘子拿走（销毁对应的栈帧）。这个过程是**后进先出（LIFO）** 的。
- **栈帧**：每个“盘子”就是一个栈帧，它是为单次函数调用分配的一块内存区域，专门用于存放该次调用的**参数、局部变量、返回地址**等信息。

​	在递归函数 `up_and_down(int n)`的例子中，每次调用都会在栈上创建一个新的栈帧，其中包含参数 `n`的一个新副本。==因此，不同调用层级中的 `n`虽然是同一个变量名，但它们在内存中拥有不同的地址，存储着不同的值。==



#### 6、实参与其对应的形参各占用独立的存储单元吗？

​	是的，在C语言中，实参和其对应的形参在大多数情况下占用的是独立的存储单元。

#### 	💾 理解内存分配： ####

- **形参的内存是临时的**：形参只有在函数被调用时才会在内存中分配临时的存储单元。一旦函数调用结束，这些分配给形参的内存单元会被立即释放。这就好比给客人准备的一把临时椅子，客人走了，椅子就被收走了。
- **实参的内存是预先存在的**：实参可以是常量、变量或表达式，它们在函数调用前就已经有确定的值和存储空间。函数调用时，实参的值会被计算出来，然后**复制**给形参。



####7、在C语言中，声明但未初始化的一个变量，其值默认是0吗？

​	在C语言中，声明但未初始化的变量，其值**并不总是0**。其默认值取决于变量的**作用域**和**存储类别**。

​	下面的表格清晰地展示了不同类型变量的默认初始值：

| 变量类型         | 作用域/存储类别            | 默认初始值           | 说明                                                   |
| :--------------- | :------------------------- | :------------------- | :----------------------------------------------------- |
| **局部变量**     | 在函数内部定义的非静态变量 | **未定义的“垃圾值”** | 值不确定，每次运行可能不同，直接使用可能导致程序错误。 |
| **全局变量**     | 在所有函数外部定义         | **0**                | 整型为0，浮点型为0.0，字符型为'\0'，指针为NULL。       |
| **静态局部变量** | 在函数内部用`static`定义   | **0**                | 与全局变量规则相同，默认初始化为0。                    |



#### 7、在C语言中，函数调用语句function((a,b),c)中含有的实参个数为多少个？

在C语言中，函数调用语句 `function((a,b),c)`中含有的实参个数为 **2个**。

- 在调用函数时，实参（实际参数）的个数由调用语句中逗号分隔的表达式数量决定。
- 在这个例子中，==`(a,b)`是一个逗号表达式：它先计算 `a`，再计算 `b`，并最终返回 `b`的值。==但整体上，`(a,b)`被视为一个独立的表达式，作为函数的第一个实参。
- `c`是第二个实参。
- 因此，尽管 `(a,b)`内部有逗号，但外层函数调用只包含两个实参：`(a,b)`和 `c`。



####8、函数的构成：C 函数是由 ▁▁▁▁▁ 构成的。

A.函数类型	B.函数名	C.参数	D.函数首部

E.返回值	    F.变量    	G.函数体	H.返回语句

| 选项            | 是否属于函数构成部分 | 说明                                                         |
| :-------------- | :------------------- | :----------------------------------------------------------- |
| **A. 函数类型** | ✅ 是                 | 即函数的**返回类型**，指定函数执行完毕后返回值的类型，如 `int`、`void`等。 |
| **B. 函数名**   | ✅ 是                 | 函数的标识符，用于调用函数。                                 |
| **C. 参数**     | ✅ 是                 | 即**形式参数列表**，是函数接收数据的接口。                   |
| **D. 函数首部** | ❌ 不是标准术语       | 通常指函数定义的第一行，包含返回类型、函数名和参数，是上述要素的组合，本身不作为一个独立的构成要素。 |
| **E. 返回值**   | ❌ 不是独立要素       | 返回值是函数执行后产生的一个结果，其类型由“函数类型（返回类型）”定义，但它本身是函数运行后的产物，而非构成函数的静态部分。 |
| **F. 变量**     | ❌ 不是               | 变量通常在函数体内声明，属于实现函数功能的工具，而非函数本身的构成要素。 |
| **G. 函数体**   | ✅ 是                 | 由 `{}`包围的代码块，包含了实现函数功能的所有语句，是函数的核心。 |
| **H. 返回语句** | ❌ 不是独立要素       | `return`语句是写在函数体内的一个具体指令，用于返回结果或结束函数，其存在取决于函数类型。 |



####9、函数是一个完成特定工作的独立程序模块，包括_______________________和____________________两种。

#### 💡 两种函数的简单说明 ####

- **库函数**：也被称为标准函数或系统函数，是由C语言编译系统预先编写好的函数，你可以直接使用。例如，我们常用的 `printf()`输出函数和 `scanf()`输入函数就是库函数。使用它们时，需要在程序开头用 `#include`指令包含相应的头文件。
- **自定义函数**：当库函数无法满足你的特定需求时，就需要自己动手编写函数，这就是自定义函数。你可以根据程序要实现的功能来定义函数名、参数和返回值。



#### 10、函数、语句、参数、变量、头文件的地位是什么？

​	下表清晰地展示了C语言中这些核心概念的定位：

| 术语       | 专业定义                                                     | 在C程序中的地位与作用                                        |
| :--------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| **头文件** | 包含**函数原型**、**宏定义**、**数据类型定义**等信息的文件，通常以 `.h`为后缀，通过 `#include`预处理指令引入。 | ==**编译单元级的引入单元**==。用于**声明**程序中所需的外部资源（如标准库函数），确保编译器能正确识别函数、类型等，是实现模块化设计和代码复用的关键。 |
| **函数**   | 一个具有**返回类型**、**函数名**、**参数列表**和**函数体**的独立代码块，用于执行一个特定的任务。 | ==**C程序的基本构建单位**==。是程序**逻辑和执行流程的主要载体**。程序从 `main`函数开始执行，通过函数调用组织代码，体现模块化编程思想。 |
| **变量**   | ==程序中用于**存储数据**的基本单元==，其属性由**数据类型**、**名称**、**值**和**存储空间**定义。 | ==**数据存储的基本单位**==。用于在程序运行期间**保存和操作数据**。其**作用域**和**生命周期**决定了数据的可访问性和存在时间。 |
| **参数**   | 函数定义中用于**接收传入值**的变量，或在函数调用时传递给函数的**实际值**。 | **函数间数据传递的接口**。允许函数接收外部数据，使其能够进行通用化处理，增强代码的灵活性和可重用性。 |
| **语句**   | ==程序中最小的**独立执行单元**==，用于表达一个完整的操作或命令，通常以分号 (`;`) 结尾或由特定控制结构定义。 | ==**函数体内的基本执行步骤**==。是构成程序**具体算法和逻辑流程**的原子操作。程序的功能通过一系列语句的顺序、选择和循环执行来实现。 |



#### 11、在C语言中，函数要被调用时，声明位置可以是哪里？如果涉及到嵌套调用，声明的位置又可以是哪里？

#### 1. 函数声明的位置 ####

- **主调函数内部声明**：这种声明属于**局部声明**，只在该主调函数内部有效。如果你有多个函数都需要调用同一个自定义函数，并且这个自定义函数定义在主调函数之后，那么你需要在每个主调函数内部都进行声明 。
- **主调函数外部声明**：这种声明属于**全局声明**。通常，我们会将函数声明放在源文件的开头，`#include`指令的下面。这样，声明之后的所有函数就都能调用它了 。这是更常见和推荐的做法，因为它避免了重复声明，让代码更清晰。

#### 2. 嵌套调用与声明位置 ####

​	**嵌套调用** 指的是在一个函数中调用另一个函数，而被调用的函数又可能继续调用其他函数 。

- 嵌套调用本身**并不直接改变函数声明的规则**。
- 声明位置的选择（函数内还是函数外）决定了**哪些函数**能够“看到”并使用这个被调用的函数。如果被嵌套调用的函数**只需要被最外层的那个主调函数使用**，你可以在最外层主调函数内部声明它。如果被嵌套调用的函数**需要被多个不同的函数（包括嵌套调用链中的各个函数）使用**，那么你就应该将它**声明在所有这些函数的外部**（通常是文件开头），作为全局声明。



####12、全局变量与局部变量的作用范围相同，不允许它们同名。这句话正确吗？

​	这句话不正确。全局变量与局部变量的作用域并不同，而且在C语言中，是允许它们同名的。

| 特性         | 全局变量 (Global Variable)                       | 局部变量 (Local Variable)                    |
| :----------- | :----------------------------------------------- | :------------------------------------------- |
| **定义位置** | 所有函数外部                                     | 函数内部或代码块内部                         |
| **作用域**   | 从定义处开始，到整个程序结束（默认）             | 仅限于定义它的函数或代码块内部               |
| **生命周期** | 整个程序的运行期间                               | 函数或代码块被调用时创建，执行完毕即销毁     |
| **同名规则** | ==当与局部变量同名时，在局部作用域内会被“屏蔽”== | 当与全局变量同名时，在自身作用域内优先被使用 |



####13、自动变量如果没有赋值，其值被自动赋为0吗？

​	这句话是**不正确**的。自动变量如果没有显式赋值，其值将是**未定义的随机值**（通常称为"垃圾值"），而**不会**被自动赋为0。为了让你更清晰地理解不同类型变量的初始化特性，我准备了一个对比表格：

| 变量类型     | 存储位置   | 生命周期               | 默认初始值         |
| :----------- | :--------- | :--------------------- | :----------------- |
| **自动变量** | 栈         | 函数/代码块执行期间    | **未定义（随机）** |
| 静态局部变量 | 静态存储区 | 整个程序运行期间       | 0                  |
| 全局变量     | 静态存储区 | 整个程序运行期间       | 0                  |
| 寄存器变量   | 寄存器或栈 | 函数/代码块执行期间    | 未定义（随机）     |
| 动态分配变量 | 堆         | 手动分配至手动释放期间 | 未定义（随机）     |



####14、追问：上面表格提到的变量分别怎么声明和调用？

​	不同类型的变量在声明、作用域和生命周期上各有特点。下面这个表格汇总了它们的核心特性。

| 存储类别         | 关键字           | 声明位置                   | 初始化特点                      | 调用（使用）方式                             | 生命周期         |
| :--------------- | :--------------- | :------------------------- | :------------------------------ | :------------------------------------------- | :--------------- |
| **自动变量**     | `auto`(通常省略) | 函数或代码块内部           | 未初始化时值为随机垃圾值        | 直接使用变量名，仅在其所在的代码块内有效     | 代码块执行期间   |
| **静态局部变量** | `static`         | 函数内部                   | 仅初始化一次，未初始化默认置为0 | 直接使用变量名，仅在其所在的函数内有效       | 整个程序运行期间 |
| **全局变量**     | 无               | 所有函数外部               | 未初始化默认置为0               | 在定义后的任何函数中直接使用变量名           | 整个程序运行期间 |
| **静态全局变量** | `static`         | 所有函数外部（在源文件中） | 未初始化默认置为0               | 在**当前源文件**内的任何函数中直接使用变量名 | 整个程序运行期间 |
| **寄存器变量**   | `register`       | 函数内部                   | 未初始化时值未定义              | 直接使用变量名，仅在其所在的代码块内有效     | 代码块执行期间   |

#### 💡 实用建议 ####

- **变量命名**：给变量起个清晰易懂的名字，比如用 `g_`前缀区分全局变量（如 `g_userCount`），用静态变量存储需要持久化的状态（如 `static int s_callTimes`）。
- **谨慎使用全局变量**：虽然全局变量用起来方便，但过多使用会让程序流程难以追踪，应优先考虑局部变量和参数传递。
- **养成初始化习惯**：**声明变量时最好立即初始化**，尤其是局部自动变量，这能避免因使用随机值导致的不可预知错误。



#### 15、文件中定义的全局变量的作用域为（）。 A. 本程序全部范围 B. 本文件全部范围

​	这是一个非常核心的C语言概念！简单来说，**正确答案是 B. 本文件全部范围**。选项A描述的情况需要满足特定条件（使用`extern`）后才能成立。下面这个表格能帮你更清晰地理解它们的区别：

| 特性         | A. 本程序全部范围                                            | B. 本文件全部范围                                            |
| :----------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| **准确描述** | 这是全局变量作用域**可以扩展到的最大范围**                   | 这是全局变量**默认的、基础的作用域范围**                     |
| **实现条件** | 需要在其他文件中使用 **`extern`关键字**进行声明              | **无需任何特殊声明**，在定义它的文件中自然具备               |
| **本质**     | ==对默认作用域的**扩展  **==                                 | 全局变量与生俱来的**基本属性**                               |
| **举例说明** | 在 `file1.c`中定义 `int globalVar;`，在 `file2.c`中通过 `extern int globalVar;`声明后，`file2.c`即可使用 `globalVar` | 在 `file1.c`中定义 `int globalVar;`，那么从定义位置开始，到 `file1.c`文件末尾的所有函数都可以直接使用它 |

### 💎 概念辨析与技巧 ###

​	你需要记住的关键点是：**“本文件全部范围”是全局变量的默认作用域。** 而“本程序全部范围”是一个可选项，需要通过`extern`关键字来主动实现。

​	在实际编程中，理解这一点至关重要，尤其是在包含多个源文件的项目中。如果不加注意地在一个以上文件中定义同名全局变量，通常会导致链接错误。**而使用`static`关键字修饰的全局变量（静态全局变量），其作用域会被限制在定义它的文件内，即使使用`extern`也无法在其他文件中使用**，这有助于提高代码的封装性和避免命名冲突。



###16、主函数的值是程序的 _____________，通常为 ______________，表示程序正常结束；否则表示程序异常结束。

​	主函数的值是程序的**退出状态**，通常为 **0**，表示程序正常结束；否则表示程序异常结束。

- **返回值的意义**：主函数（`main`函数）的返回值是一个整数，它被传递给操作系统（或调用环境），用以指示程序的执行结果是成功还是遇到了错误。返回 `0`通常表示程序**成功执行**；返回**非零值**（通常是正整数）则代表程序在执行过程中出现了某种错误或异常情况，不同的非零值可以对应不同的错误类型。
- **隐式返回值**：在 C99 及之后的 C 语言标准以及 C++ 标准中，如果程序员没有在 `main`函数末尾显式地写 `return`语句，编译器会自动为其添加 `return 0;`。这意味着程序如果顺利执行到最后，会被认为是成功退出。不过，为了代码的清晰性和可移植性，**显式地写出 `return`语句是一个更好的编程习惯**。



### 17、在一段程序中不调用函数而直接将两个整型变量a和b的值互换，一定是可以不借助第三个变量完成的吗？

​	因为在不调用函数的情况下，直接交换两个整型变量a和b的值，确实**总是可以**不借助第三个变量完成的。C语言提供了巧妙的方法！比如：

- **使用算术运算**：`a = a + b; b = a - b; a = a - b;`但要注意，如果a和b的值很大，可能会有整数溢出的风险。
- **使用异或运算（更安全）**：`a = a ^ b; b = a ^ b; a = a ^ b;`这种方法不会溢出。



###18、递归函数的两个要素是___________________________ 与 _________________________。

​	递归函数最重要的两个要素是**边界条件**和**递归方程**。

​	**边界条件**防止无限循环导致栈溢出；而**递归方程**则是将大问题拆解成小问题的核心逻辑。

---

## 代码实例：

####1、main函数里面的局部变量x与y，可不可以看作名字相同但实质是与全局变量x，y不一样的变量？

```c
int x = 5, y = 7;
void swap ( )
{
      int z ;
      z = x ;  x = y ;  y = z ;
}
int main(void)
{
      int x = 3, y = 8;
      swap ( ) ;
      printf ("%d,%d \n", x , y ) ;
      return 0 ;
}
```

​	是的，你的理解完全正确！`main`函数内部的局部变量`x`和`y`，与在函数外部定义的全局变量`x`和`y`，**虽然名字相同，但它们是两个完全不同的变量**，在内存中占据不同的位置，拥有不同的作用域和生命周期。

#### 🔄 代码执行过程回顾 ####

​	让我们结合这个理解，再快速回顾一下你提供的代码执行流程：

1. **程序开始**：全局变量 `x`和 `y`被创建并初始化为5和7。
2. **进入`main`函数**：`main`函数的局部变量 `x`和 `y`被创建并初始化为3和8。从这一刻起，在`main`函数中，`x`和`y`指的就是这些局部变量。
3. **调用`swap()`函数**：`swap`函数内部没有定义局部变量`x`和`y`，也没有参数传入。因此，当它使用`x`和`y`时，它找不到局部变量，于是向更大的全局作用域寻找，找到了全局变量`x`和`y`。所以，`swap`函数交换的是全局变量的值（全局`x`变为7，全局`y`变为5）。这个操作**完全不影响**`main`函数中局部变量`x`和`y`的值。
4. **执行`printf`**：这条语句在`main`函数中，所以它打印的是`main`的局部变量`x`和`y`，它们的值从未改变，因此输出`3, 8`。
