# C语言知识点·数据类型篇

## 基础知识：

### 1、各种数据类型的占用字节数

| 数据类型                                   | 通常在32位系统的大小 | 通常在64位系统的大小 | 备注与说明                                                   |
| :----------------------------------------- | :------------------- | :------------------- | :----------------------------------------------------------- |
| **`char`** / **`unsigned char`**           | 1 字节               | 1 字节               | 大小固定，通常用于字符或小整数。                             |
| **`short`** / **`unsigned short`**         | 2 字节               | 2 字节               | 大小通常固定。                                               |
| **`int`** / **`unsigned int`**             | 4 字节               | 4 字节               | 在大多数现代32位和64位系统中常见。                           |
| **`long`** / **`unsigned long`**           | 4 字节               | 8 字节               | **大小与系统架构关系密切**，是32位和64位系统的主要区别之一。 |
| **`long long`** / **`unsigned long long`** | 8 字节               | 8 字节               | 大小通常固定，用于表示非常大的整数。                         |
| **`float`**                                | 4 字节               | 4 字节               | 单精度浮点数。                                               |
| **`double`**                               | 8 字节               | 8 字节               | 双精度浮点数。                                               |
| **`long double`**                          | 8/12/16 字节         | 16 字节              | 大小和实现方式多变，取决于编译器和硬件平台。                 |
| **指针类型** (如 `int*`, `void*`)          | 4 字节               | 8 字节               | **大小由系统寻址能力决定**。32位系统寻址空间为232，需4字节存储地址；64位系统为264，需8字节。所有数据类型指针的大小通常相同。 |
| **`size_t`**                               | 4 字节               | 8 字节               | 无符号整数类型，通常用于表示对象大小或数组索引，其大小与指针类型一致。 |



###2、八进制与十六进制是怎样的？

C语言中的八进制和十六进制数在处理底层数据时非常有用。下面这个表格汇总了它们的核心知识点，方便你快速掌握：

| 特性                 | 八进制数                                       | 十六进制数                                      |
| -------------------- | ---------------------------------------------- | ----------------------------------------------- |
| **表示格式（前缀）** | 以数字 `0`开头，如 `0123`                      | 以 `0x`或 `0X`开头，如 `0x1A3F`                 |
| **输入格式符**       | `scanf`中使用 `%o`                             | `scanf`中使用 `%x`(小写) 或 `%X`(大写)          |
| **输出格式符**       | `printf`中使用 `%o`                            | `printf`中使用 `%x`(小写) 或 `%X`(大写)         |
| **带前缀输出**[1](a) | 使用 `%#o`(如 `0123`)                          | 使用 `%#x`(如 `0x1a3f`) 或 `%#X`(如 `0X1A3F`)   |
| **固定宽度输出**     | 例如 `%6o`(右对齐, 宽度6), `%06o`(补零, 宽度6) | 例如 `%4x`, `%04x`；常用 `%02x`确保字节输出两位 |

[1](a)==若不带前缀则没有`#`。==

💡 **表示方法与输入输出**

​	在C语言中，你通过不同的前缀来告诉编译器一个整数是何种进制。

- **八进制 (Octal)** 以数字 `0`开头，后面跟0-7的数字。例如 `010`表示十进制的8 。
- **十六进制 (Hexadecimal)** 以 `0x`或 `0X`开头，后面跟0-9以及A-F（或a-f）的字符。例如 `0x10`表示十进制的16 。

​	在代码中直接赋值时，务必加上正确的前缀：

```
int oct_val = 023;   // 八进制23，等于十进制19
int hex_val = 0x1A;  // 十六进制1A，等于十进制26
```

​	使用 `scanf`进行输入时，格式化字符串告诉函数如何解释输入的数字：

```
int num;
scanf("%o", &num);   // 输入八进制数，无需加前缀0
scanf("%x", &num);   // 输入十六进制数，无需加前缀0x
```

​	使用 `printf`进行输出时，格式控制符决定了显示形式。通过添加 `#`标志可以输出带前缀的易读格式，使用宽度和补零修饰符则可以控制对齐和位数，这在输出如MAC地址、颜色代码等数据时非常有用。

```
int value = 26;
printf("八进制: %o, 带前缀: %#o\n", value, value);   // 输出: 32, 032
printf("十六进制: %x, 带前缀小写: %#x, 带前缀大写: %#X\n", value, value, value); 
// 输出: 1a, 0x1a, 0X1A
printf("固定两位十六进制: %02X\n", 15); // 输出: 0F
```

🧮 **运算**

​	八进制和十六进制数在参与运算时非常直观，因为它们存入变量后，在计算机内部都会转换成二进制进行运算。你可以像使用十进制数一样对它们进行加、减、乘、除等数学运算。

```
int a = 010;  // 八进制10，十进制8
int b = 0x10; // 十六进制10，十进制16
int sum = a + b; // 8 + 16 = 24
```

​	由于八进制和十六进制能直观地反映二进制位模式，它们在**位运算**中尤其常见。例如，使用十六进制数来设置或清除特定的位：

```
int flags = 0x0F;   // 二进制: 0000 1111
flags |= 0xF0;      // 按位或操作，结果: 1111 1111 (十六进制 0xFF)
```

⚠️ **注意事项与常见错误**

- **前缀是关键**：在代码中直接书写八进制或十六进制数时，**一定不要忘记前缀**（八进制的 `0`，十六进制的 `0x`）。`123`是十进制，`0123`是八进制，`0x123`是十六进制，它们是不同的数。
- **负数的表示**：八进制和十六进制也可以表示负数，例如 `-012`或 `-0x1A`。计算机会以其补码形式进行处理。
- **输出格式的选择**：在调试或需要明确表示进制的输出中，建议使用 `%#o`、`%#x`或 `%#X`，这样输出结果自带前缀，可读性更好。

🔧 **实际应用场景**

- **文件权限管理**：在Unix/Linux系统中，文件权限常使用八进制数表示，如 `0755`。
- **内存地址与硬件寄存器**：内存地址通常用十六进制表示，如 `0x7fff5fbff710`。在嵌入式编程中，硬件寄存器也常用十六进制或八进制来配置。
- **颜色代码**：在图形编程或网页设计中，颜色值常用十六进制表示，如 `0xFF5733`。
- **位操作与掩码**：十六进制和八进制因其与二进制的便捷转换，广泛用于位标志、掩码设置等场景。

















---

##答疑：

### 1、1000 0000作为八位二进制补码，表示哪一个十进制数？

你给出的二进制数 `1000 0000`作为八位二进制补码，表示的十进制数是 **-128**。

#### 🔍 转换方法说明 ####

负数的原码与补码转换遵循清晰的规律，具体如下：

🔁 **原码转补码**

负数的**原码转换为补码**的方法是：**符号位保持不变，数值位按位取反，最后整体加1**。

🔁 **补码转原码**

负数的**补码转换回原码**同样有两种等效方法：

- **方法一**：**符号位保持不变，先整体减1，然后数值位按位取反**。
- **方法二**：**符号位保持不变，数值位先按位取反，然后整体加1**。

​	但对于 `1000 0000`这个特殊的编码，我们也可以从另一个角度来理解它的值。

​	一种有效的方法是使用**加权法**来计算。对于 `1000 0000`：只有符号位（权重为-128）是 `1`，其余位都是 `0`。所以，其表示的十进制数值为：**(-128) + 0 + 0 + 0 + 0 + 0 + 0 + 0 = -128**。

#### ⚠️ 特殊情况的说明 ####

​	`1000 0000`是一个比较特殊的补码表示。你可能已经注意到，如果严格按照“取反加一”的流程（取反得 `0111 1111`，加一得 `1000 0000`，这个二进制数如果直接转换是128，加上负号是-128），会发现一个有趣的现象：`-128`的补码计算结果恰好是 `1000 0000`本身。

​	==在八位补码体系中，`1000 0000`被直接定义为表示最小的负数 **-128**。==这样做的一个重要原因是解决了“负零”（原本原码可能表示为 `1000 0000`）的问题，使得零（`0000 0000`）的表示唯一，并且将可表示的负数范围扩展了一个，达到了 -128。

==因此，-128 并没有对应的原码和反码形式。==



### 2、0的补码是多少？

- **0的补码** 表示为 `00000000`。
- 补码的设计使得 **0只有一种表示形式**，解决了原码和反码中存在的"+0"和"-0"问题（例如，原码中+0为`00000000`，-0为`10000000`；反码中+0为`00000000`，-0为`11111111`）。在补码系统中，`-0`的补码计算时，其反码`11111111`加1的结果是`1 00000000`，由于位宽限制，最高位的1被舍弃，最终得到的结果也是`00000000`，与`+0`的表示完全相同 。

💡 **为什么补码是标准**

​	计算机系统采用补码来表示和存储数值，主要基于以下关键优势 ：

- **确保0的唯一表示**：避免了原码和反码中存在的正负零歧义，简化了硬件对零值的判断逻辑 。
- **统一加减法运算**：补码使得加法运算可以同时处理正数和负数，减法运算可以转换为加法（加上一个负数）来进行，计算机CPU无需设计单独的减法器，降低了硬件复杂度 。例如，计算 `3 - 3`可以转化为 `3 + (-3)`，使用补码直接相加：`00000011`(+3的补码) + `11111101`(-3的补码) = `1 00000000`，舍弃溢出的最高位后，结果正是`00000000`(0的补码) 。







###4、在C语言中，八进制、十六进制数的长短可以随大小而变化吗？

在C语言中，八进制和十六进制整型常量本身的“长短”（即书写时的位数）并不能随意变化，它必须遵循严格的语法规则，但其表示的数值大小是可以变化的。简单来说，**书写位数有明确限制，而数值大小取决于变量类型** 。

下面的表格清晰地展示了它们在表示方法上的核心规则与区别。

| 进制         | 前缀        | 合法数字      | 常量的位数规则 (书写格式)                                    | 表示的数值范围 (取决于变量类型)                         |
| :----------- | :---------- | :------------ | :----------------------------------------------------------- | :------------------------------------------------------ |
| **八进制**   | `0`         | 0-7           | 必须是1-3位数字，例如 `\123`（转义字符）或 `0123`（整型常量）。 | 可存入 `char`、`int`、`long`等类型，数值范围相应变化 。 |
| **十六进制** | `0x`或 `0X` | 0-9, A-F, a-f | 必须是1-2位数字，例如 `\xFF`（转义字符）或 `0xFFFF`（整型常量）。 | 可存入 `char`、`int`、`long`等类型，数值范围相应变化 。 |

#### 💡 位数规则详解与注意事项 ####

理解表格中的基本规则后，还需要注意一些关键的细节和例外情况，以避免代码错误。

- **位数的限制原因**：八进制转义字符`\ddd`限制为3位，十六进制转义字符`\xhh`限制为2位，主要是因为它们的目的是表示一个**单字节**（8位）的字符值。一个字节所能表示的最大值用八进制是`\377`，用十六进制是`\xFF`（均为十进制的255）。
- **位数不足与超出**：**位数不足**时，通常按预期处理。例如，八进制数 `\34`和 `\034`是等价的。**位数超出**则会导致问题。例如，八进制转义字符 `\1234`会被理解为 `\123`和字符 `'4'`两个部分。而十六进制转义字符如果超过两位，例如 `\x123`，其行为是**未定义的**，不同编译器处理方式不同，可能导致错误或意外结果。
- **非法字符的处理**：如果在八进制转义字符中使用了数字8或9等非法字符，例如 `\018`，编译器的行为会变得复杂，它可能不再被当作一个单字节的转义字符来解释，从而导致难以排查的错误。因此，务必确保使用合法的数字。
- **整型常量与长整型**：对于普通的整型常量（非转义字符），如果你需要表示一个非常大的、超出普通 `int`类型范围的八进制或十六进制数，可以通过在数字后添加后缀 `L`或 `l`来指明它为长整型（`long`），例如 `0123L`或 `0xABCDEFL`。这时，虽然书写位数变多了，但这是通过改变**数据类型**而非进制本身的规则来实现的。



### 5、C语言中可以精确地存储一个小数吗？

​	C语言中确实**不能总是精确存储一个小数**。C语言用 **浮点数类型**（float/double）存储小数，采用的是二进制科学计数法。但像 0.1 这样简单的十进制小数，转换成二进制会是无限循环小数（比如 0.1₁₀ = 0.0001100110011...₂），正如三分之一在十进制中无法精确表示。

```
float a = 0.1;
printf("%.20f", a); 
// 可能输出 0.10000000149011611938 而不是精确的 0.1
```

​	**如果需要高精度计算**：

- 对钱这类需要精确值的数据，可以用 **整型以分为单位存储**
- 或者使用特殊的高精度数学库（例如 GMP）



### 5、'\0' '0' 0有什么区别？

| 特征               | `\0`(空字符)                   | `0`(数字零)                    | `'0'`(字符零)                 |
| :----------------- | :----------------------------- | :----------------------------- | :---------------------------- |
| **本质与用途**     | 字符常量，字符串的**结束标志** | 整型常量，表示**数值零**       | 字符常量，表示**数字字符'0'** |
| **数据类型**       | `char`                         | `int`(或其他数值类型)          | `char`                        |
| **ASCII码值**      | **0**                          | 0 (作为数值)                   | **48**                        |
| **内存表示(字节)** | `00000000`                     | `0x00000000`(假设`int`为4字节) | `00110000`                    |
| **简单示例**       | `char end = '\0';`             | `int count = 0;`               | `char digit = '0';`           |



### 6、float、double型分别可以存储几位十进制小数？

在C语言中，**float**（单精度浮点数）通常可以保证大约**6到7位**有效的十进制数字，而**double**（双精度浮点数）则可以保证大约**15到16位**有效的十进制数字。

为了让你更清晰地对比，请看下表：

| 特性                   | float (单精度)        | double (双精度)         |
| :--------------------- | :-------------------- | :---------------------- |
| **存储空间**           | 4字节 (32位)          | 8字节 (64位)            |
| **有效十进制位数**     | 约 6 - 7 位           | 约 15 - 16 位           |
| **数值范围（绝对值）** | 约 1.2E-38 到 3.4E+38 | 约 2.2E-308 到 1.8E+308 |

#### 💡 理解“有效数字”与存储原理 ####

​	这里的“有效数字”指的是从第一个非零数字开始计算的数字位数。例如，对于数字 `123.456789`：

- 用 `float`存储，可能只能精确表示为 `123.4567`（后两位不准确）。
- 用 `double`存储，则能更精确地表示为 `123.456789`。

​	这种精度差异的根本原因在于它们在内存中的表示方式遵循 **IEEE 754 标准**。一个浮点数由符号位、指数位和尾数位三部分组成。`double`的尾数位（52位）远多于 `float`（23位），因此能够表示更精确的小数部分。





###8、在c语言中，不允许有常量的数据类型是（    ）

**A.整型			B.结构型**

**C.字符型  		  D.字符串**

| 选项  | 数据类型   | 是否允许有常量 | 常量举例               |
| :---- | :--------- | :------------- | :--------------------- |
| A     | 整型       | 是             | `100`, `0xFF`, `0750L` |
| **B** | **结构型** | **否**         | 无语法支持             |
| C     | 字符型     | 是             | `'A'`, `'\n'`          |
| D     | 字符串     | 是             | `"Hello, World!"`      |

#### 原因解析 ####

​	核心原因在于，C语言标准没有为**结构体（struct）** 这种复合数据类型提供直接表示“常量”的语法。所谓常量，是指其值在程序运行期间固定不变。

​	你可以使用 `const`关键字来限定一个结构体变量，使其内容在初始化后不应被改变。但这并非严格意义上的“结构体常量”。因为即使在现代C标准中，一个被 `const`限定的结构体变量仍然不满足“常量表达式”的要求，不能用于需要编译时常量的场合，例如定义数组的长度或作为 `case`标签的值。

​	此外，像整型、字符型等基本类型的常量，可以直接通过字面值（如 `5`, `'a'`）来表达。而结构体由多个不同类型的成员组成，语言本身没有提供一种字面值语法来直接表示一个完整的、不可变的结构体常量值。
